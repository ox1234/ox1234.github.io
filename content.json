{"meta":{"title":"技术改变世界，文化改变人心","subtitle":"一个专注于web安全的web狗","description":null,"author":"flight","url":"http://yoursite.com"},"pages":[{"title":"links","date":"2018-07-26T14:57:21.000Z","updated":"2018-07-28T05:18:14.802Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"double-r’s blog pupil’s blog qiqi’s blog quincy’s blog void0red’s blog"},{"title":"关于我","date":"2018-07-25T02:02:28.000Z","updated":"2018-07-26T14:36:42.501Z","comments":true,"path":"whoami/index.html","permalink":"http://yoursite.com/whoami/index.html","excerpt":"","text":"专注于web安全，热爱一切美的东西，喜欢音乐，喜欢吉他，喜欢尝试新的东西，在计算机这条深不见底的洞里面越走越远，估计是脱不了坑了 身边有一堆大佬朋友还是很靠谱的，给一些各位神的链接"}],"posts":[{"title":"实例化漏洞和XXE","slug":"实例化任意对象漏洞","date":"2018-07-28T06:32:05.186Z","updated":"2018-07-28T12:12:49.162Z","comments":true,"path":"2018/07/28/实例化任意对象漏洞/","link":"","permalink":"http://yoursite.com/2018/07/28/实例化任意对象漏洞/","excerpt":"","text":"一道实例化漏洞和XXE结合的题题目源码1234567891011121314151617181920212223//index.php&lt;?phpshow_source(__FILE__);class NotFound&#123; function __construct() &#123; die('404'); &#125;&#125;spl_autoload_register( function ($class)&#123; new NotFound(); &#125;);$classname = isset($_GET['name']) ? $_GET['name'] : null;$param = isset($_GET['param']) ? $_GET['param'] : null;$param2 = isset($_GET['param2']) ? $_GET['param2'] : null;if(class_exists($classname))&#123; $newclass = new $classname($param,$param2); var_dump($newclass); foreach ($newclass as $key=&gt;$value) echo $key.'=&gt;'.$value.'&lt;br&gt;';&#125; 1234//flag13Here.php&lt;?php$flag = \"HRCTF&#123;X33_W1tH_S1mpl3Xml3l3m3nt&#125;\";?&gt; 解法分析先看可控的点： 有三个get参数的点可以控制，分别是$classname,$param,$param2 再往后看，$classname可以让我们实例化一个类，这个类是我们可控的，而且可以控制该类构造方法的前两个参数 这个地方很容易想到PHP的内置类：SimpleXMLElement，可以进行xxe攻击，但是我们现在不知道flag文件的名字，这个时候可以用PHP中的另外一个内置类：GlobIterator，可以列出来所有匹配的文件名（这个类有点像glob://协议）： 根据文档，很容易理解GlobIterator类的构造方式，而第二个参数控制的是输出的键值，可以选择0，所以构造payload： ?name=GlobIterator&amp;param1=./*.php&amp;param2=0 发现成功读出当前目录的文件 现在已经知道了flag的文件名，那么我们可以构造SimpleXMLElement类来进行XXE来读取flag文件的内容 先看一下SimpleXMLElement的构造方法 第一个参数可以是XML的文件路径，可以是XML文件内容，也可以是URL（需要第三个参数为true） 第二个参数为系统预定义的常量，具体的意义如下： 为了避免一些特殊字符的错误，我们将结果进行base64编码： 构造payload为：name=SimpleXMLElement&amp;param=/Library/WebServer/Documents/PhpProjects/CTF_php/flag13Here.php&amp;param2=2 即可读取到结果：","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"安全技术","slug":"安全技术","permalink":"http://yoursite.com/tags/安全技术/"}]},{"title":"TP框架学习笔记(视图)","slug":"TP框架学习笔记(视图)","date":"2018-07-28T05:49:24.907Z","updated":"2018-07-28T12:14:25.245Z","comments":true,"path":"2018/07/28/TP框架学习笔记(视图)/","link":"","permalink":"http://yoursite.com/2018/07/28/TP框架学习笔记(视图)/","excerpt":"","text":"模版定义某个模块的模版文件是独立的，默认的模版文件定义规则是： `视图目录/[模版主题]/控制器名/操作名+视图后缀 默认的视图目录是模块的View目录，框架默认的视图后缀为.html， eg: Home模块下的User控制器的add方法对应的模版文件路径为： `Application/Home/View/User/add.html 如果项目的视图不是View的话，可以通过&#39;DEFAULT_V_LAYER&#39; =&gt; &#39;Template&#39;来更改 如果需要更改后缀，可以更改： &#39;TEMPL_TEMPLATE_SUFFIX&#39; =&gt; &#39;tpl&#39; 模版主题如果某个模块要支持多个主题的话，可以使用模版主题功能 配置：&#39;DEFAULT_THEME&#39; =&gt; &#39;main&#39; 模版赋值如果要在模版中输出变量，需要在控制器中把变量传递给模版，系统提供了assign方法对变量赋值 模版渲染可以使用display函数","categories":[],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"OneThink CMS的缓存漏洞的分析","slug":"OneThink CMS的缓存漏洞的分析","date":"2018-07-27T14:50:39.716Z","updated":"2018-07-28T12:15:29.088Z","comments":true,"path":"2018/07/27/OneThink CMS的缓存漏洞的分析/","link":"","permalink":"http://yoursite.com/2018/07/27/OneThink CMS的缓存漏洞的分析/","excerpt":"","text":"第一次分析漏洞，跟着其他师傅的分析过程自己走了一遍，有的地方不太懂也查清楚了，写一遍加深记忆吧 0x01 漏洞利用条件 OneThink1.0 并且/Temp/Runtime目录可读可写 0x02 漏洞分析因为TP对缓存设计逻辑的漏洞，以及缓存文件名可猜测的原因，导致了这个漏洞 先看一下TP的缓存文件的配置： TP中一些系统常量的定义都在ThinkPHP/ThinkPHP.php中定义，缓存路径也在这里： 可以看到其中的TEMP_PATH默认值为Runtime/Temp目录 而缓存文件存储的位置在ThinkPHP/Conf/convention.php 我们开始从登陆开始一步步分析OneThink在登陆的时候缓存文件是如何存储的： 在抓包以后，我们发现请求的地址为/home/user/login.html，那么跟踪这个请求，我们可以定位到Home模块的UserController控制器中的login方法： 其中在登陆成功以后调用了$Member中的login方法，传入的$uid是从数据库中查询出来的用户名对应的用户id 其中的D函数是TP中获取model的方法，这里相当于获得了一个MemberModel类的实例，我们进入MemberModel中查看一下其中的login函数 其中的$user是从$uid中拿到的，也就是用户名 在登陆用户的时候调用了autoLogin函数，进入这个函数里面查看 里面调用了get_username函数，继续跟入 终于找到了对于用户名的缓存操作 在第一次登陆的时候是没有缓存的，if条件应该直接进入else部分，又因为$list是从$uid所在行的第二行拿到的，所以应该是用户名，所以在下面调用S方法缓存数据的时候传入的$list我们是可控的 再进入S函数，查看一下这个函数的具体设计 我们传入的$list就是S函数中的value参数，分析if条件的话可以知道程序直接进入第二个elseif，初始化$cache，关键在最后的set函数，set函数中的$value仍然是我们可控的，进入set函数中，set函数在ThinkPHP/Library/Think/Cache/Driver/File.class.php 发现$filename被file_put_contents直接调用，如果不开启数据压缩的话，$data则是我们控制的$value序列化以后存入的值 现在我们可以控制文件中的一部分内容，知道了文件存储的目录，如果我们知道文件名就好了，那么我们进入filename函数里面看一下缓存文件的文件名是怎么定义的 因为一般没有开启DATA_CACHE_SUBDIR，所以判断直接跳到else部分，而options[‘prefix’]是空的，所以最后的文件名为md5($name).php 现在我们构造payload： 用户名注册为%0aphpinfo();#这样在存储缓存文件的时候就可以写入webshell，#注释了序列化的剩余部分，前面的%0a的作用则是为了不让$data中&lt;?php\\n//&quot;.sprintf(&#39;%012d&#39;,$expire).$check.$data.&quot;\\n?&gt;的’//‘注释攻击代码 0x03 漏洞利用在OneThink的注册页面中的注册用户名为:%0aphpinfo();#，并且用burp抓包将%0a解码 之后用这个用户名登陆，同样抓包将%0a解码，之后访问Temp/Runtime/用户名md5.php，即可发现phpinfo得以执行 查看缓存文件的内容，可以发现payload的原理： 0x04 总结这是第一次这么系统的分析一个漏洞，可以说学到了很多，最近也在学TP框架，正好也是一个巩固和提高，虽然是跟着别人的路走的，但是仍然很艰难，可能是第一次分析漏洞吧，这是第一次，但不是最后一次，希望下次能更游刃有余吧","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"}]},{"title":"TP框架学习笔记(模型)","slug":"TP学习笔记(模型)","date":"2018-07-26T05:41:18.062Z","updated":"2018-07-27T14:54:24.115Z","comments":true,"path":"2018/07/26/TP学习笔记(模型)/","link":"","permalink":"http://yoursite.com/2018/07/26/TP学习笔记(模型)/","excerpt":"","text":"模型模型定义模型不是必须定义的，只有当存在额外的逻辑或者属性的时候才需要定义，TP约定的模型命名规则是去除表前缀的数据表名称，使用首字母大写的格式再加上Model eg: 数据表名称为think_user，则它的模型名称为UserModel 模型实例化 new实例化 模型本质也是PHP的类，所以可以直接用new实例化 eg: $user =new Model(&#39;User&#39;); Model类的构造方法有三个参数(去除表前缀的数据表名称，表前缀，连接配置） M函数实例化 M函数为model函数的简写，和Model类的构造方法相同 D函数实例化 D和M的区别：D函数可以自动检测模型类，如果存在指定模型类，则实例化该模型类，否则实例化”Think\\Model”类，而M函数只会实例化”Think\\Model”类 空模型实例化 如果只需要执行SQL，不需要其他操作的话，可以实例化一个空模型类 eg: 123$m = new Model(); //等效于 $m = M();$data = $m-&gt;query('SELECT * FROM c5_User');print_r($data); 连贯操作若是需要查询User模型中的status为1的前10条记录，并且按照时间倒序排序，可以通过如下代码实现 12$user = M('User');$list = $user-&gt;where('status=1')-&gt;order('create_time desc')-&gt;limit(10)-&gt;select(); 常用的支持连贯操作的方法 where: 支持字符串，数组和对象 alias: 设置当前数据表的别名 data: 用来设置当前模型需要操作的数据，未经$model-&gt;create()方法处理过的数据，TP不能直接使用 比如： 123456$model = M('User');$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');$model-&gt;add($data); 上面这一段代码会报错，因为没有经过model-&gt;create()方法处理 改为： 1234567$model = M('User');$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');$model-&gt;create($data);$model-&gt;add($data); 使用data方法： 12345$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');M('User')-&gt;data($data)-&gt;add(); field: 用来选择需要返回的字段 order: 用来排序 limit: 用来限制返回结果的数量 page: 分页操作 group: 结果分组 having: 筛选经过group分组以后且满足条件的数据集 join: 进行连表查询 CURD操作C：create，插入数据U：update，更新数据R：read，读取数据D：delete，删除数据 创建数据自动根据表单POST数据创建数据： 12$user = M('User');$user-&gt;create(); //该代码会自动读取post中的数据 从数组创建数据对象： 123456$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');$user = M('User');$user-&gt;create($data); create方法的第二个参数知指明该操作时插入还是更新操作 注：create操作产生的数据并没有真正写入数据库，而是再屌用add或者save方法以后才会操作数据库 插入数据TP插入数据使用add方法： 123456$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');$user = M('User');$user-&gt;create($data)-&gt;add(); 读取数据TP可以读取字段值，单条数据，数据集 读取字段值使用getField方法 12$model = M('User');$score = $model-&gt;where('id=3')-&gt;getField('score'); 读取单条数据使用find方法 123456//方法1:$model = M('User');$model-&gt;find(1);//方法2:$model = M('User');$model-&gt;where('id=1')-&gt;find(); 读取数据集使用select方法 12$model = M('User');$model-&gt;where('score &gt; 100')-&gt;select(); 更新数据TP中的数据更新包括更新记录和更新字段 更新记录使用save方法 123456$data = array('nickname' =&gt; 'hehe');$model = M('User');$model = create($data);$model = where('id=1').save($data); 更新字段使用setField方法 123456789//更新字段$model = M('User');$model-&gt;where('id=1')-&gt;setField('score',100);//更新统计字段$model = M('User');$model-&gt;where('id=1')-&gt;setDec('score',100);$model = M('Article');$model-&gt;where('id=1')-&gt;setInc('views',1); 删除数据使用delete方法 12$model = M('Article');$model-&gt;delete(1); 注：为了避免错删数据，如果没有任何条件进行删除操作的话，不会执行删除操作 自动验证数据验证有两种方式： 静态方式：在模型类中通过$_validate定义 动态方式：使用模型类的validate方法 验证规则： 123array( array(字段名,验证规则,错误提示,[验证条件,附加规则,验证场景])); 自动完成自动完成的两种方式： 静态方式：在模型里面通过$_auto属性定义处理机制 动态方式：使用模型类的auto方法动态创建自动处理机制 定义规则 格式： 123array(array(完成字段,完成规则,[完成条件,附加规则])); 完成字段：需要完成的字段名完成规则：以何种规则处理该字段完成条件：可自动完成的条件(self::MODEL_BOTH,self::MODEL_UPDATE,self::MODEL_INSERT) 视图模型视图一般指数据库的视图，视图是一个虚拟表，也有列和数据，视图常用来解决HAS_ONE和BELONGS_TO类型的关联查询 继承ViewModel类 配置其中的$viewFields数组 1234public $viewFields = array( 'Post' =&gt; array('post_id','title','content','created_at','updated_at'), 'User' =&gt; array('username' =&gt; 'author', '_on' =&gt; 'Post.user_id=User.id') ); 关联模型处理HAS_MANY之类的关系 关联关系包括： 一对一 一对多 多对多 HAS_ONE,BELONGS_TO,HAS_MANY,MANY_TO_MANY 要执行关联查询，模型类需要继承RelationModel，并且配置$_link属性 HAS_ONE12345678public $_link = array( 'extra' =&gt; array( 'mapping_type' =&gt; self::HAS_ONE, 'class_name' =&gt; 'UserExtra', 'foreign_key' =&gt; 'user_id', 'mapping_fields' =&gt; 'email,qq' )); BELONGS_TO1234567public $_link = array( 'author' =&gt; array( 'mapping_type' =&gt; self::BELONGS_TO, 'class_name' =&gt; 'User', 'foreign_key' =&gt; 'user_id' ));","categories":[],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"TP框架学习笔记(控制器)","slug":"TP框架学习笔记(控制器)","date":"2018-07-25T06:53:38.606Z","updated":"2018-07-26T14:30:31.311Z","comments":true,"path":"2018/07/25/TP框架学习笔记(控制器)/","link":"","permalink":"http://yoursite.com/2018/07/25/TP框架学习笔记(控制器)/","excerpt":"","text":"控制器控制器的定义控制器的作用：它起着沟通视图和模型的作用 文件名形式：xxxController.php&quot; 这里给一个例子：http://localhost/PhpProjects/thinPHP/thinkphp_3/home/test localhost是主机名 PhpProjects/thinPHP/thinkphp_3为目录路径 home为模块名 第一个test是控制器名 第二个test是动作名 当方法名为php关键字的时候，则需要配置”操作方法后缀” 配置项名称：&#39;ACTION_SUFFIX&#39; =&gt; &#39;Action&#39; 前置操作和后置操作可以通过:_before_index(),_after_index()来实现前置操作和后置操作 动作参数绑定参数绑定通过直接绑定URL地址中的变量为操作方法的形参 可以通过URL_PARAMS_BIND来开启和关闭动作参数绑定 123public function bind($id=1)&#123; echo $id;&#125; 若在IndexController.class.php中加入以上代码，即可通过访问如下的URL获取id值，而不用使用$_GET[&#39;id&#39;] eg: http://localhost/PhpProjects/thinPHP/thinkphp_3/home/index/bind/id/1 若不传入id参数，形如：http://localhost/PhpProjects/thinPHP/thinkphp_3/home/index/bind/id/ 则默认值为1 伪静态伪静态是为了优化SEO的效果，TP可以通过URL_HTML_SUFFIX来配置为静态 默认的URL_HTML_SUFFIX是以.html为后缀 设置：&#39;URL_HTML_SUFFIX&#39; =&gt; &#39;html&#39; 如果要禁止某些后缀的访问，可以通过设置URL_DENY_SUFFIX 设置：&#39;URL_DENY_SUFFIX&#39; =&gt; &#39;htm&#39; URL大小写配置项：URL_CASE_INSENSITIVE 此项配置可以实现URL不区分大小写 设置：&#39;URL_CASE_INSENSITIVE&#39; =&gt; &#39;true&#39; 设置完成以后： http://localhost/PhpProjects/thinPHP/thinkphp_3/home/index/Index http://localhost/PhpProjects/thinPHP/thinkphp_3/home/index/index 以上两个URL是等价的 URL生成TP中的U函数：U(地址表达式,参数,是否显示伪静态后缀,是否显示域名) 地址表达式： [模块/控制器/操作#锚点@域名]?参数1=值1&amp;参数2=值2... 注意：如果没有指定模块民给，则TP使用当前模块名 参数 参数支持数组和字符串形式，以下方式是等效的： U(&#39;User/View&#39;,array(&#39;id&#39;=&gt;1,&#39;role&#39;=&gt;&#39;admin&#39;)) U(&#39;User/view&#39;,&#39;id=1&amp;role=admin&#39;) 伪静态后缀 改参数为true的时候，系统读取URL_HTML_SUFFIX配置来生成URL，如果需要临时更换规则，可以直接加参数后缀名 eg: U(&#39;Blog/view&#39;,array(&#39;id&#39;=&gt;1),&#39;shtml&#39;) URL模式处理 不同的URL_MODEL会生成不同的URL Ajax返回1234567public function index()&#123; $data = array( 'status' =&gt; 1, 'data' =&gt; 'data' ); $this-&gt;ajaxReturn($data,'xml');&#125; 可以通过ajaxReturn方法来返回json或xml格式的数据 其中第二个参数为返回的数据格式 重定向和页面跳转重定向通过Controller中redirect()方法实现跳转 页面跳转通过sucess和error方法实现跳转 succes和error方法的第一个参数为提示信息，第二个参数为指向URL，第三个参数为等待时间 HTTP请求方法TP中提供了几个常量来判断HTTP请求： IS_GET,IS_POST,IS_PUT,IS_DELETE,IS_AJAX,REQUEST_METHOD 可以通过以下代码判断是否为POST或者GET方法 123456789public function login()&#123; if(IS_POST)&#123; echo '当前请求为post方法'; &#125;else if(IS_GET)&#123; echo '当前请求为get方法'; &#125;else&#123; echo '非法请求'; &#125;&#125; 读取输入TP中使用I函数来进行变量的获取和过滤 eg: echo I(&#39;post.username&#39;); == echo $_POST[&#39;username&#39;] I函数可以设置默认值，过滤方法，正则过滤 空操作当TP找不到请求的操作的时候，会执行_empty方法 在控制器中添加_empty方法可以实现对错误界面的优化 空控制器当TP找不到请求的控制器的时候，会去找EmptyController，和空操作一样，页可以定制错误界面和URL优化 注：CONTROLLER_NAME代表的是当前请求的控制器名称","categories":[],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"TP框架学习笔记(路由)","slug":"TP框架学习笔记(路由)","date":"2018-07-24T14:41:57.890Z","updated":"2018-07-26T15:00:38.157Z","comments":true,"path":"2018/07/24/TP框架学习笔记(路由)/","link":"","permalink":"http://yoursite.com/2018/07/24/TP框架学习笔记(路由)/","excerpt":"","text":"路由URL的三种模式 动态URL eg: www.example.com/index.php?id=1 这种在URL中使用”?,=,&amp;”等传递参数的URL被称为动态路由 静态URL eg: www.example.com/index.html 这种常以”.html,.htm,.xml”结尾的网站与后台没有交互，不需要编译即可运行 伪静态URL eg: www.example.com/post/1 这种URL看起来像是静态页面，但是其实不是静态页面，只是运用了URL Rewrite技术来优化搜索引擎 TP的路由 普通模式：http://www.example.com/index.php?m=home&amp;c=index&amp;a=index pathinfo模式：http://www.example.com/index.php/home/index/index rewrite模式：http://www.example.com/home/index/index 兼容模式：http://www.example.com/index.php?s=home/index/index TP通过URL_ROUTER_ON来开启自定义路由规则，并且通过URL_ROUTE_RULES来定义路由的规则 路由定义的一般规则：&quot;路由表达式&quot; =&gt; &quot;路由地址和参数&quot; 路由表达式：以何种规则匹配浏览器中的地址，如果匹配成功，系统在处理请求的同时把传入参数传给制定动作 路由表达式支持：规则路由，正则路由，静态路由 规则路由eg: &#39;posts/:yead/:month/:day&#39; =&gt; &#39;Index/index&#39; 通过:来进行参数匹配，如果匹配成功，则将该为孩子的参数传给制定的动作 正则路由eg: &#39;/^posts\\/(\\d{4})\\/(\\d{2})\\/(\\d{2})$/&#39; =&gt; &#39;Index/index?year=:1&amp;month=:2&amp;day=1&#39; 通过正则匹配来匹配URL 静态路由注意：静态路由通过URL_MAP_RULES定义 eg: &#39;site/welcome&#39; =&gt; &#39;Index/index?from=seo","categories":[],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]}]}