{"meta":{"title":"技术改变世界，文化改变人心","subtitle":"一个专注于web安全的web狗","description":null,"author":"flight","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2018-07-25T02:02:28.000Z","updated":"2018-07-25T02:04:57.229Z","comments":true,"path":"whoami/index.html","permalink":"http://yoursite.com/whoami/index.html","excerpt":"","text":"专注于web安全，"}],"posts":[{"title":"TP框架学习笔记(控制器)","slug":"TP学习笔记(模型)","date":"2018-07-26T05:41:18.062Z","updated":"2018-07-26T10:21:35.052Z","comments":true,"path":"2018/07/26/TP学习笔记(模型)/","link":"","permalink":"http://yoursite.com/2018/07/26/TP学习笔记(模型)/","excerpt":"","text":"TP学习笔记(模型)模型模型定义模型不是必须定义的，只有当存在额外的逻辑或者属性的时候才需要定义，TP约定的模型命名规则是去除表前缀的数据表名称，使用首字母大写的格式再加上Model eg: 数据表名称为think_user，则它的模型名称为UserModel 模型实例化 new实例化 模型本质也是PHP的类，所以可以直接用new实例化 eg: $user =new Model(&#39;User&#39;); Model类的构造方法有三个参数(去除表前缀的数据表名称，表前缀，连接配置） M函数实例化 M函数为model函数的简写，和Model类的构造方法相同 D函数实例化 D和M的区别：D函数可以自动检测模型类，如果存在指定模型类，则实例化该模型类，否则实例化”Think\\Model”类，而M函数只会实例化”Think\\Model”类 空模型实例化 如果只需要执行SQL，不需要其他操作的话，可以实例化一个空模型类 eg: 123$m = new Model(); //等效于 $m = M();$data = $m-&gt;query('SELECT * FROM c5_User');print_r($data); 连贯操作若是需要查询User模型中的status为1的前10条记录，并且按照时间倒序排序，可以通过如下代码实现 12$user = M('User');$list = $user-&gt;where('status=1')-&gt;order('create_time desc')-&gt;limit(10)-&gt;select(); 常用的支持连贯操作的方法 where: 支持字符串，数组和对象 alias: 设置当前数据表的别名 data: 用来设置当前模型需要操作的数据，未经$model-&gt;create()方法处理过的数据，TP不能直接使用 比如： 123456$model = M('User');$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');$model-&gt;add($data); 上面这一段代码会报错，因为没有经过model-&gt;create()方法处理 改为： 1234567$model = M('User');$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');$model-&gt;create($data);$model-&gt;add($data); 使用data方法： 12345$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');M('User')-&gt;data($data)-&gt;add(); field: 用来选择需要返回的字段 order: 用来排序 limit: 用来限制返回结果的数量 page: 分页操作 group: 结果分组 having: 筛选经过group分组以后且满足条件的数据集 join: 进行连表查询 CURD操作C：create，插入数据U：update，更新数据R：read，读取数据D：delete，删除数据 创建数据自动根据表单POST数据创建数据： 12$user = M('User');$user-&gt;create(); //该代码会自动读取post中的数据 从数组创建数据对象： 123456$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');$user = M('User');$user-&gt;create($data); create方法的第二个参数知指明该操作时插入还是更新操作 注：create操作产生的数据并没有真正写入数据库，而是再屌用add或者save方法以后才会操作数据库 插入数据TP插入数据使用add方法： 123456$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');$user = M('User');$user-&gt;create($data)-&gt;add(); 读取数据TP可以读取字段值，单条数据，数据集 读取字段值使用getField方法 12$model = M('User');$score = $model-&gt;where('id=3')-&gt;getField('score'); 读取单条数据使用find方法 123456//方法1:$model = M('User');$model-&gt;find(1);//方法2:$model = M('User');$model-&gt;where('id=1')-&gt;find(); 读取数据集使用select方法 12$model = M('User');$model-&gt;where('score &gt; 100')-&gt;select(); 更新数据TP中的数据更新包括更新记录和更新字段 更新记录使用save方法 123456$data = array('nickname' =&gt; 'hehe');$model = M('User');$model = create($data);$model = where('id=1').save($data); 更新字段使用setField方法 123456789//更新字段$model = M('User');$model-&gt;where('id=1')-&gt;setField('score',100);//更新统计字段$model = M('User');$model-&gt;where('id=1')-&gt;setDec('score',100);$model = M('Article');$model-&gt;where('id=1')-&gt;setInc('views',1); 删除数据使用delete方法 12$model = M('Article');$model-&gt;delete(1); 注：为了避免错删数据，如果没有任何条件进行删除操作的话，不会执行删除操作 自动验证数据验证有两种方式： 静态方式：在模型类中通过$_validate定义 动态方式：使用模型类的validate方法 验证规则： 123array( array(字段名,验证规则,错误提示,[验证条件,附加规则,验证场景])); 自动完成自动完成的两种方式： 静态方式：在模型里面通过$_auto属性定义处理机制 动态方式：使用模型类的auto方法动态创建自动处理机制 定义规则 格式： 123array(array(完成字段,完成规则,[完成条件,附加规则])); 完成字段：需要完成的字段名完成规则：以何种规则处理该字段完成条件：可自动完成的条件(self::MODEL_BOTH,self::MODEL_UPDATE,self::MODEL_INSERT) 视图模型视图一般指数据库的视图，视图是一个虚拟表，也有列和数据，视图常用来解决HAS_ONE和BELONGS_TO类型的关联查询 继承ViewModel类 配置其中的$viewFields数组 1234public $viewFields = array( 'Post' =&gt; array('post_id','title','content','created_at','updated_at'), 'User' =&gt; array('username' =&gt; 'author', '_on' =&gt; 'Post.user_id=User.id') ); 关联模型处理HAS_MANY之类的关系 关联关系包括： 一对一 一对多 多对多 HAS_ONE,BELONGS_TO,HAS_MANY,MANY_TO_MANY 要执行关联查询，模型类需要继承RelationModel，并且配置$_link属性 HAS_ONE12345678public $_link = array( 'extra' =&gt; array( 'mapping_type' =&gt; self::HAS_ONE, 'class_name' =&gt; 'UserExtra', 'foreign_key' =&gt; 'user_id', 'mapping_fields' =&gt; 'email,qq' )); BELONGS_TO1234567public $_link = array( 'author' =&gt; array( 'mapping_type' =&gt; self::BELONGS_TO, 'class_name' =&gt; 'User', 'foreign_key' =&gt; 'user_id' ));","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"}]},{"title":"TP框架学习笔记(控制器)","slug":"TP框架学习笔记(控制器)","date":"2018-07-25T06:53:38.606Z","updated":"2018-07-26T00:48:08.709Z","comments":true,"path":"2018/07/25/TP框架学习笔记(控制器)/","link":"","permalink":"http://yoursite.com/2018/07/25/TP框架学习笔记(控制器)/","excerpt":"","text":"控制器控制器的定义控制器的作用：它起着沟通视图和模型的作用 文件名形式：xxxController.php&quot; 这里给一个例子：http://localhost/PhpProjects/thinPHP/thinkphp_3/home/test localhost是主机名 PhpProjects/thinPHP/thinkphp_3为目录路径 home为模块名 第一个test是控制器名 第二个test是动作名 当方法名为php关键字的时候，则需要配置”操作方法后缀” 配置项名称：&#39;ACTION_SUFFIX&#39; =&gt; &#39;Action&#39; 前置操作和后置操作可以通过:_before_index(),_after_index()来实现前置操作和后置操作 动作参数绑定参数绑定通过直接绑定URL地址中的变量为操作方法的形参 可以通过URL_PARAMS_BIND来开启和关闭动作参数绑定 123public function bind($id=1)&#123; echo $id;&#125; 若在IndexController.class.php中加入以上代码，即可通过访问如下的URL获取id值，而不用使用$_GET[&#39;id&#39;] eg: http://localhost/PhpProjects/thinPHP/thinkphp_3/home/index/bind/id/1 若不传入id参数，形如：http://localhost/PhpProjects/thinPHP/thinkphp_3/home/index/bind/id/ 则默认值为1 伪静态伪静态是为了优化SEO的效果，TP可以通过URL_HTML_SUFFIX来配置为静态 默认的URL_HTML_SUFFIX是以.html为后缀 设置：&#39;URL_HTML_SUFFIX&#39; =&gt; &#39;html&#39; 如果要禁止某些后缀的访问，可以通过设置URL_DENY_SUFFIX 设置：&#39;URL_DENY_SUFFIX&#39; =&gt; &#39;htm&#39; URL大小写配置项：URL_CASE_INSENSITIVE 此项配置可以实现URL不区分大小写 设置：&#39;URL_CASE_INSENSITIVE&#39; =&gt; &#39;true&#39; 设置完成以后： http://localhost/PhpProjects/thinPHP/thinkphp_3/home/index/Index http://localhost/PhpProjects/thinPHP/thinkphp_3/home/index/index 以上两个URL是等价的 URL生成TP中的U函数：U(地址表达式,参数,是否显示伪静态后缀,是否显示域名) 地址表达式： [模块/控制器/操作#锚点@域名]?参数1=值1&amp;参数2=值2... 注意：如果没有指定模块民给，则TP使用当前模块名 参数 参数支持数组和字符串形式，以下方式是等效的： U(&#39;User/View&#39;,array(&#39;id&#39;=&gt;1,&#39;role&#39;=&gt;&#39;admin&#39;)) U(&#39;User/view&#39;,&#39;id=1&amp;role=admin&#39;) 伪静态后缀 改参数为true的时候，系统读取URL_HTML_SUFFIX配置来生成URL，如果需要临时更换规则，可以直接加参数后缀名 eg: U(&#39;Blog/view&#39;,array(&#39;id&#39;=&gt;1),&#39;shtml&#39;) URL模式处理 不同的URL_MODEL会生成不同的URL Ajax返回1234567public function index()&#123; $data = array( 'status' =&gt; 1, 'data' =&gt; 'data' ); $this-&gt;ajaxReturn($data,'xml');&#125; 可以通过ajaxReturn方法来返回json或xml格式的数据 其中第二个参数为返回的数据格式 重定向和页面跳转重定向通过Controller中redirect()方法实现跳转 页面跳转通过sucess和error方法实现跳转 succes和error方法的第一个参数为提示信息，第二个参数为指向URL，第三个参数为等待时间 HTTP请求方法TP中提供了几个常量来判断HTTP请求： IS_GET,IS_POST,IS_PUT,IS_DELETE,IS_AJAX,REQUEST_METHOD 可以通过以下代码判断是否为POST或者GET方法 123456789public function login()&#123; if(IS_POST)&#123; echo '当前请求为post方法'; &#125;else if(IS_GET)&#123; echo '当前请求为get方法'; &#125;else&#123; echo '非法请求'; &#125;&#125; 读取输入TP中使用I函数来进行变量的获取和过滤 eg: echo I(&#39;post.username&#39;); == echo $_POST[&#39;username&#39;] I函数可以设置默认值，过滤方法，正则过滤 空操作当TP找不到请求的操作的时候，会执行_empty方法 在控制器中添加_empty方法可以实现对错误界面的优化 空控制器当TP找不到请求的控制器的时候，会去找EmptyController，和空操作一样，页可以定制错误界面和URL优化 注：CONTROLLER_NAME代表的是当前请求的控制器名称","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"}]},{"title":"TP框架学习笔记(路由)","slug":"TP框架学习笔记(路由)","date":"2018-07-24T14:41:57.890Z","updated":"2018-07-26T00:48:21.591Z","comments":true,"path":"2018/07/24/TP框架学习笔记(路由)/","link":"","permalink":"http://yoursite.com/2018/07/24/TP框架学习笔记(路由)/","excerpt":"","text":"路由URL的三种模式 动态URL eg: www.example.com/index.php?id=1 这种在URL中使用”?,=,&amp;”等传递参数的URL被称为动态路由 静态URL eg: www.example.com/index.html 这种常以”.html,.htm,.xml”结尾的网站与后台没有交互，不需要编译即可运行 伪静态URL eg: www.example.com/post/1 这种URL看起来像是静态页面，但是其实不是静态页面，只是运用了URL Rewrite技术来优化搜索引擎 TP的路由 普通模式：http://www.example.com/index.php?m=home&amp;c=index&amp;a=index pathinfo模式：http://www.example.com/index.php/home/index/index rewrite模式：http://www.example.com/home/index/index 兼容模式：http://www.example.com/index.php?s=home/index/index TP通过URL_ROUTER_ON来开启自定义路由规则，并且通过URL_ROUTE_RULES来定义路由的规则 路由定义的一般规则：&quot;路由表达式&quot; =&gt; &quot;路由地址和参数&quot; 路由表达式：以何种规则匹配浏览器中的地址，如果匹配成功，系统在处理请求的同时把传入参数传给制定动作 路由表达式支持：规则路由，正则路由，静态路由 规则路由eg: &#39;posts/:yead/:month/:day&#39; =&gt; &#39;Index/index&#39; 通过:来进行参数匹配，如果匹配成功，则将该为孩子的参数传给制定的动作 正则路由eg: &#39;/^posts\\/(\\d{4})\\/(\\d{2})\\/(\\d{2})$/&#39; =&gt; &#39;Index/index?year=:1&amp;month=:2&amp;day=1&#39; 通过正则匹配来匹配URL 静态路由注意：静态路由通过URL_MAP_RULES定义 eg: &#39;site/welcome&#39; =&gt; &#39;Index/index?from=seo","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"}]}]}