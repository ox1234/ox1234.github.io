{"meta":{"title":"技术改变世界，文化改变人心","subtitle":"一个专注于web安全的web狗","description":null,"author":"flight","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2018-07-25T02:02:28.000Z","updated":"2018-07-26T14:36:42.501Z","comments":true,"path":"whoami/index.html","permalink":"http://yoursite.com/whoami/index.html","excerpt":"","text":"专注于web安全，热爱一切美的东西，喜欢音乐，喜欢吉他，喜欢尝试新的东西，在计算机这条深不见底的洞里面越走越远，估计是脱不了坑了 身边有一堆大佬朋友还是很靠谱的，给一些各位神的链接"},{"title":"links","date":"2018-07-26T14:57:21.000Z","updated":"2018-08-05T09:05:12.558Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"double-r’s blog pupil’s blog qiqi’s blog quincy’s blog void0red’s blog koocola’s blog 欣佬’s blog"}],"posts":[{"title":"web安全思维导图","slug":"web安全思维导图","date":"2019-03-12T10:09:54.093Z","updated":"2019-03-12T10:11:27.731Z","comments":true,"path":"2019/03/12/web安全思维导图/","link":"","permalink":"http://yoursite.com/2019/03/12/web安全思维导图/","excerpt":"","text":"思维导图","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"ThinkPHP-5.0.* RCE分析","slug":"ThinkPHP-5.0.* RCE分析","date":"2019-01-23T02:18:40.118Z","updated":"2019-01-23T02:18:40.119Z","comments":true,"path":"2019/01/23/ThinkPHP-5.0.* RCE分析/","link":"","permalink":"http://yoursite.com/2019/01/23/ThinkPHP-5.0.* RCE分析/","excerpt":"","text":"前几周一直在复习考试，也没有看最近出的一些洞，寒假闲下来以后，要把最近出的洞都补了 漏洞核心TP的这个RCE漏洞，主要的触发点在Request类中的method方法，这个存在一个当前类的任意方法调用，之后通过这个任意方法调用去覆盖掉filter的默认方法，从而实现RCE 可以看到在526行，调用了$this-&gt;{$this-&gt;method}($_POST)，在这里，因为$this-&gt;method和$_POST我们都可控，可以调用当前类的任意方法， 漏洞分析程序流程 在App.php中，在116行的$dispatch = self::routeCheck($request,$config);进入URL路由检测 通过URL检测，TP获取到执行的控制器为captcha 在以下的调用栈中获取到了请求方法的type为method 之后回到Route.php调用了$method = strtolower($request-&gt;method();这里就是触发点 进入$request-&gt;method() 这里如果传入的POST数组设置了配置中的var_method的话，可以进入条件判断，我们看一下var_method是什么值 所以，如果我们传入的POST数组中有_method键值对的话就可以直接进入逻辑 进入逻辑后，很容易看出来，$this-&gt;method的值是我们的_method的值，我们可以利用这一点来执行当前类的任意方法 在当前类的__construct()方法中，传入的是一个数组，我们可以通过_method再一次调用这个类的__construct函数如果这个类没有可以用来进行一些恶意操作的函数的话，这个当前类的任意方法调用并没有什么用，但是巧的是，在__construct函数中有着变量覆盖，这样的话，我们就可以覆盖整个类中的所有成员变量，我们看看__construct函数 传入的参数是一个数组，正好我们之前的方法调用的参数正好是POST数组，而且在139行有一个很明显的变量赋值的操作，而且这个变量的键和值我们都可控，意味着我们可以进行当前类的变量覆盖，当然，显而易见的filter变量应该是最好的选择，因为filter会对所有传入的参数进行一次函数调用 最后，我们将filter的值覆盖为系统函数system 这里我们同时赋值$this-&gt;method的值为get，因为captcha路由规则需要是get方法才能不出错 在路由结束以后，调用了$data = self::exec($dispatch, $config); 因为在之前的路由中，判断路由的类型是method，所以进入了method的逻辑 这里又回到了Request类的方法调用，还记得我们之前对Reuqest类的变量覆盖吗，在这一步获取了filter的值，但是在之前，我们把filter覆盖为了system 在下面调用array_walk_recursive方法将$data的值都应用filterValue函数 最后，filterValue会对$data内的每个值都调用filter函数，这个时候，filter为system，data中为whoami 最后成功实现RCE 总结TP的此次RCE是因为对传入的_method没有进行过滤，所以TP在之后的修复中，也是对其中的_method设置了白名单 现在的web漏洞已经不再是以前的一个SQL注入，命令执行打天下的时代了，现在web的漏洞很多都需要很长的调用链才可以将整个攻击连贯起来","categories":[],"tags":[{"name":"漏洞分析,TP","slug":"漏洞分析-TP","permalink":"http://yoursite.com/tags/漏洞分析-TP/"}]},{"title":"MetInfo SQL注入漏洞详解","slug":"MetInfo SQL注入漏洞详解","date":"2018-10-17T03:17:26.454Z","updated":"2018-10-17T10:51:06.783Z","comments":true,"path":"2018/10/17/MetInfo SQL注入漏洞详解/","link":"","permalink":"http://yoursite.com/2018/10/17/MetInfo SQL注入漏洞详解/","excerpt":"","text":"MetInfo SQL注入漏洞详解前言之前CNVD爆出了一个最新版本的MetInfoSQL注入漏洞，根据payload正向分析了一遍漏洞原理，写一篇详细一点的 参数回溯payload: admin/index.php?m=web&amp;n=message&amp;c=message&amp;a=domessage&amp;action=add&amp;lang=cn&amp;para137=1&amp;para186=1&amp;para138=1&amp;para139=1&amp;para140=1&amp;id=42 and 1=1 需要在管理员页面触发，为一个bool类型的SQL盲注 问题出现在/app/message/web/message.class.php中的add函数 12345678910111213141516//message类public function add($info) &#123; global $_M; if(!$_M[form][id])&#123; $message=DB::get_one(\"select * from &#123;$_M[table][column]&#125; where module= 7 and lang ='&#123;$_M[form][lang]&#125;'\"); $_M[form][id]=$message[id]; &#125; $met_fd_ok=DB::get_one(\"select * from &#123;$_M[table][config]&#125; where lang ='&#123;$_M[form][lang]&#125;' and name= 'met_fd_ok' and columnid = &#123;$_M[form][id]&#125;\"); $_M[config][met_fd_ok]= $met_fd_ok[value]; if(!$_M[config][met_fd_ok])okinfo('javascript:history.back();',\"&#123;$_M[word][Feedback5]&#125;\"); if($_M[config][met_memberlogin_code])&#123; if(!load::sys_class('pin', 'new')-&gt;check_pin($_M['form']['code']))&#123; okinfo(-1, $_M['word']['membercode']); &#125; &#125; 可以看到在第七行处的$_M[form][id]并没有被单引号包裹，出现了SQL注入漏洞，我们再回溯变量看看$_M[form][id]是从哪里来的，可以看到第二行定义了全局变量$_M 123456//message类public function __construct() &#123; global $_M; parent::__construct(); $this-&gt;upfile = load::sys_class('upfile', 'new'); &#125; 并且在message的构造方法中也定义了$_M，且未初始化，判断$_M在message的构造方法中被赋值，在构造方法中还调用了父类的__construct方法 12345678910111213141516//web类public function __construct() &#123; parent::__construct(); global $_M; // 可视化窗口语言栏跳转后，整个可视化页面跳转到新语言 if(strpos($_SERVER['HTTP_REFERER'], 'pageset=1')!==false &amp;&amp; strpos($_SERVER['HTTP_REFERER'], 'lang=')!==false &amp;&amp; strpos($_SERVER['HTTP_REFERER'], $_M['url']['site'])!==false)&#123; preg_match('/lang=(\\w+)/', $_SERVER['HTTP_REFERER'], $prev_lang); if($prev_lang &amp;&amp; $prev_lang[1] !=$_M['lang'])&#123; $new_url=\"&#123;$_M['url']['site_admin']&#125;index.php?lang=&#123;$_M['lang']&#125;&amp;n=ui_set&amp;pageset=1\"; echo \"&lt;script&gt; parent.document.getElementsByClassName('page-iframe')[0].setAttribute('data-dynamic','&#123;$_M['url']['site']&#125;index.php?lang=&#123;$_M['lang']&#125;'); parent.window.location.href='&#123;$new_url&#125;'; &lt;/script&gt;\"; die; &#125; &#125; 在web类的构造方法中并没有发现对$_M的赋值操作，而且web类又调用了父类的构造方法，继续回溯web类父类的构造方法 123456789101112//common类public function __construct() &#123; global $_M;//全局数组$_M ob_start();//开启缓存 $this-&gt;load_mysql();//数据库连接 $this-&gt;load_form();//表单过滤 $this-&gt;load_lang();//加载语言配置 $this-&gt;load_config_global();//加载全站配置数据 $this-&gt;load_url_site(); $this-&gt;load_config_lang();//加载当前语言配置数据 $this-&gt;load_url();//加载url数据 &#125; 在这里的load_form函数中对传入的GPC参数进行了过滤和赋值，并且将处理过的GPC转存到$_M中 至此，我们找到了$_M赋值的地方，此时类的继承关系为：common-&gt;web-&gt;message 123456789101112131415161718192021222324252627protected function load_form() &#123; global $_M; $_M['form'] =array(); isset($_REQUEST['GLOBALS']) &amp;&amp; exit('Access Error'); foreach($_COOKIE as $_key =&gt; $_value) &#123; $_key&#123;0&#125; != '_' &amp;&amp; $_M['form'][$_key] = daddslashes($_value); &#125; foreach($_POST as $_key =&gt; $_value) &#123; $_key&#123;0&#125; != '_' &amp;&amp; $_M['form'][$_key] = daddslashes($_value); &#125; foreach($_GET as $_key =&gt; $_value) &#123; $_key&#123;0&#125; != '_' &amp;&amp; $_M['form'][$_key] = daddslashes($_value); &#125; if(is_numeric($_M['form']['lang']))&#123;//伪静态兼容 $_M['form']['page'] = $_M['form']['lang']; $_M['form']['lang'] = ''; &#125; if($_M['form']['metid'] == 'list')&#123; $_M['form']['list'] = 1; $_M['form']['metid'] = $_M['form']['page']; $_M['form']['page'] = 1; &#125; if(!preg_match('/^[0-9A-Za-z]+$/', $_M['form']['lang']) &amp;&amp; $_M['form']['lang'])&#123; echo \"No data in the database,please reinstall.\"; die(); &#125; &#125; 在load_form函数中我们发现了赋值给$_M的过程和过滤函数daddslashes，跟入查看 1234567891011121314151617181920212223/** * 对字符串进行反斜杠处理，如果服务器开启MAGIC_QUOTES_GPC。则不处理。 * @param string/array $string 处理的字符串或数组 * @param bool $force 是否强制反斜杠处理 * @return array 返回处理好的字符串或数组 */function daddslashes($string, $force = 0) &#123; !defined('MAGIC_QUOTES_GPC') &amp;&amp; define('MAGIC_QUOTES_GPC', get_magic_quotes_gpc()); if(!MAGIC_QUOTES_GPC || $force) &#123; if(is_array($string)) &#123; foreach($string as $key =&gt; $val) &#123; $string[$key] = daddslashes($val, $force); &#125; &#125; else &#123; if(!defined('IN_ADMIN'))&#123; $string = trim(addslashes(sqlinsert($string))); &#125;else&#123; $string = trim(addslashes($string)); &#125; &#125; &#125; return $string;&#125; 在没有定义IN_ADMIN的时候在addslashes之前还调用了sqlinsert函数，这也就是为什么作者说在第一次尝试注入的时候发现SQL关键词都被清除了，所以我们需要找到一个地方定义了IN_ADMIN来绕过sqlinsert函数 正向分析即然我们需要IN_ADMIN值不为false，根据字面意思判断，就可以知道需要在管理页面找，而admin/index.php正好定义了IN_ADMIN的值 而且在此文件中我们可以更改GET参数来调用各种模型，类名，操作名(操作名必须以do开头) 作者找到了domessage函数可以触发add方法，并且将GET的参数全部传递过去，成功注入，鉴于里面的逻辑太复杂，直接使用xdebug跟踪函数调用 输入payload之后直接跟到调用add函数的位置，可以在PHPstorm中看到所有的函数调用关系 在_load_class中实例化了message类 在实例化的时候调用message类的构造方法，调用了message父类web的父类common的构造方法，并且使用了load_form过滤了传入的GPC参数，这个地方在跟踪的时候发现居然跳到了web类中实现的load_form函数，刚开始有点迷，后来想清楚了 在学面向对象的时候继承是一个很重要的概念，而这个时候就是面向对象的一个特性，此时调用方法是：$this-&gt;load_form();//表单过滤，可以看到当前的\\$this指向的是message类，这个时候去message类找load_form()函数，发现没有这个函数，根据继承的特性，程序向message类的父类去找load_form()函数，发现它的父类实现了load_form，所以直接调用message父类的load_form，而这个函数 12345678910111213141516171819202122/** * 重写common类的load_form方法，前台对提交的GET，POST，COOKIE进行安全的过滤处理 */ protected function load_form() &#123; global $_M; parent::load_form(); foreach ($_M['form'] as $key =&gt; $val) &#123; $_M['form'][$key] = sqlinsert($val); &#125; if ($_M['form']['id']!='' &amp;&amp; !is_numeric($_M['form']['id'])) &#123; $_M['form']['id'] = ''; &#125; if ($_M['form']['class1']!='' &amp;&amp; !is_numeric($_M['form']['class1'])) &#123; $_M['form']['class1'] = ''; &#125; if ($_M['form']['class2']!='' &amp;&amp; !is_numeric($_M['form']['class2'])) &#123; $_M['form']['class2'] = ''; &#125; if ($_M['form']['class3']!='' &amp;&amp; !is_numeric($_M['form']['class3'])) &#123; $_M['form']['class3'] = ''; &#125; &#125; 可以看到这里对每一个table传入的参数进行一次sqlinsert过滤，按理来说我们的payload已经被过滤了，通过监视$_M，确实我们的payload已经为空了 但是为什么我们的payload最后还能执行呢，再跟踪函数，我发现在调用完web类的load_form函数之后，调用了$this-&gt;upfile = load::sys_class(&#39;upfile&#39;, &#39;new&#39;);，在这个函数中又重新调用了common的构造方法，结果把payload又赋值给了$_M 这个时候我们的payload又回到了$_M的id参数中 这个时候，可以确定payload可以拼接入SQL语句中，但是接下来还需要将所有逻辑走通，接下来解答几个问题 为什么需要paraXXX参数在执行domessage函数的时候，可以看到在执行add函数之前执行了一个check_field函数，我们进入查看 123456789101112131415161718192021222324252627282930313233343536function check_field()&#123; global $_M; $messagecfg= load::mod_class('message/message_handle','new')-&gt;get_message_config(load::mod_class('message/message_database','new')-&gt;get_message_columnid()); $met_message_fd_class=$_M[form]['para'.$messagecfg[met_message_fd_class][value]]; $met_message_fd_content=$_M[form]['para'.$messagecfg[met_message_fd_content][value]]; $met_message_fd_email=$_M[form]['para'.$messagecfg[met_message_fd_email][value]]; $met_message_fd_sms=$_M[form]['para'.$messagecfg[met_message_fd_sms][value]]; $met_fd_back=$messagecfg[met_fd_back][value]; $paralist=load::mod_class('parameter/parameter_database','new')-&gt;get_parameter('7'); foreach ($paralist as $key =&gt; $val) &#123; $para[$val[id]]=$val; &#125; $paraarr = array(); foreach (array_keys($_M['form']) as $vale) &#123; if (strstr($vale, 'para')) &#123; if (strstr($vale, '_')) &#123; $arr = explode('_',$vale); $paraarr[] = str_replace('para','',$arr[0]); &#125;else&#123; $paraarr[] = str_replace('para','',$vale); &#125; &#125; &#125; foreach (array_keys($para) as $val) &#123; if($para[$val]['wr_ok']==1 &amp;&amp; !in_array($val,$paraarr))&#123; $info=\"【&#123;$para[$val]['name']&#125;】\".$_M[word][noempty]; okinfo('javascript:history.back();',$info); &#125; &#125; //met_message_fd_class 姓名 //met_message_fd_content 留言内容 //met_message_fd_email 邮箱 // met_message_fd_sms 电话 &#125; 下面这些变量就是我们传入参数中paraXXX的内容： 12345$met_message_fd_class=$_M[form]['para'.$messagecfg[met_message_fd_class][value]];$met_message_fd_content=$_M[form]['para'.$messagecfg[met_message_fd_content][value]];$met_message_fd_email=$_M[form]['para'.$messagecfg[met_message_fd_email][value]];$met_message_fd_sms=$_M[form]['para'.$messagecfg[met_message_fd_sms][value]];$met_fd_back=$messagecfg[met_fd_back][value]; 这一行if($para[$val][&#39;wr_ok&#39;]==1 &amp;&amp; !in_array($val,$paraarr))判断了我们传入的参数中有无paraXXX 我们需要在传入的参数中有137,186,138,139,140，否则会进入if条件中的逻辑 12$info=\"【&#123;$para[$val]['name']&#125;】\".$_M[word][noempty];okinfo('javascript:history.back();',$info); 为什么id必须为42123$met_fd_ok=DB::get_one(\"select * from &#123;$_M[table][config]&#125; where lang ='&#123;$_M[form][lang]&#125;' and name= 'met_fd_ok' and columnid = &#123;$_M[form][id]&#125;\");$_M[config][met_fd_ok]= $met_fd_ok[value];if(!$_M[config][met_fd_ok])okinfo('javascript:history.back();',\"&#123;$_M[word][Feedback5]&#125;\"); 可以看到，从数据库中取出$_met_fd_ok的值，如果$_met_fd_ok[value]不为空的话，继续往下执行，我们进入数据库看看这条语句到底取出来的是哪些值 可以看到我们想让它的返回不为空，id的值必须为42或者44，所以我们的注入的时候必须保证id的值为44或者42 总结metinfo的SQL注入漏洞是作者在几次给metinfo提交后met官方不予理睬才曝光的，希望厂商能多多重视安全吧","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"安全技术","slug":"安全技术","permalink":"http://yoursite.com/tags/安全技术/"}]},{"title":"TP框架源码分析","slug":"TP框架源码分析","date":"2018-10-14T15:49:10.450Z","updated":"2018-10-17T10:43:23.377Z","comments":true,"path":"2018/10/14/TP框架源码分析/","link":"","permalink":"http://yoursite.com/2018/10/14/TP框架源码分析/","excerpt":"","text":"TP框架源码分析TP框架执行流程图接下来几篇文章，通过xdebug的单步调试一步一步分析TP框架的源码，搞清楚他的框架实现，以及一些错误，异常，钩子等等的手法，看看我们的请求到底在TP内部产生了哪些变化 0x01 记录内存使用(4)12345// 记录开始运行时间$GLOBALS['_beginTime'] = microtime(TRUE);// 记录内存初始使用define('MEMORY_LIMIT_ON',function_exists('memory_get_usage'));if(MEMORY_LIMIT_ON) $GLOBALS['_startUseMems'] = memory_get_usage(); microtime — 返回当前 Unix 时间戳和微秒数 第2，3行判断了memory_get_usage方法是否存在，如果存在的话则调用memory_get_usage方法得到系统为php分配的内存，并且在全局变量中注册，下图为当前各变量的值和状态 0x02 各种常量定义(5) 定义了各种不同的url模式，在配置文件中可以更改 定义了类文件的后缀名为.class.php 定义了一些路径常量 THINK_PATH: /usr/local/var/www/test/ThinkPHP/ TP框架各种核心文件的根目录 LIB_PATH: /usr/local/var/www/test/ThinkPHP/Library/ 类库目录 APP_PATH: ./Application/ 应用目录 COMMON_PATH: ./Application/Common/ 应用公共目录 RUNTIME_PATH: ./Application/Runtime/ 应用运行目录 判断是否为SAE环境，如果不是为普通模式，存储类型默认为FILE 定义各种核心类库，运行时目录等等在运行时需要的路径常量，都是与之前的路径常量拼接得到的 0x03 对运行环境的判断123456789101112131415161718192021222324252627282930// 系统信息if(version_compare(PHP_VERSION,'5.4.0','&lt;')) &#123; ini_set('magic_quotes_runtime',0); define('MAGIC_QUOTES_GPC',get_magic_quotes_gpc()? true : false);&#125;else&#123; define('MAGIC_QUOTES_GPC',false);&#125;define('IS_CGI',(0 === strpos(PHP_SAPI,'cgi') || false !== strpos(PHP_SAPI,'fcgi')) ? 1 : 0 );define('IS_WIN',strstr(PHP_OS, 'WIN') ? 1 : 0 );define('IS_CLI',PHP_SAPI=='cli'? 1 : 0);if(!IS_CLI) &#123; // 当前文件名 if(!defined('_PHP_FILE_')) &#123; if(IS_CGI) &#123; //CGI/FASTCGI模式下 $_temp = explode('.php',$_SERVER['PHP_SELF']); define('_PHP_FILE_', rtrim(str_replace($_SERVER['HTTP_HOST'],'',$_temp[0].'.php'),'/')); &#125;else &#123; define('_PHP_FILE_', rtrim($_SERVER['SCRIPT_NAME'],'/')); &#125; &#125; if(!defined('__ROOT__')) &#123; $_root = rtrim(dirname(_PHP_FILE_),'/'); define('__ROOT__', (($_root=='/' || $_root=='\\\\')?'':$_root)); &#125;&#125;// 加载核心Think类require CORE_PATH.'Think'.EXT; 通过PHP版本和函数判断GPC是否开启，在5.4.0版本以下可以通过get_magic_quotes_gpc()来判断GPC是否开启，在5.4.0以后GPC被废除，所以直接定义MAGIC_QUOTES_GPC为false 判断PHP的SAPI是否为CGI，是否为WIN或者CLI 如果不是CLI模式，并且没有定义_PHP_FILE_的话，就定义_PHP_FILE_的值为当前脚本的路径(即为index.php入口文件的路径) 定义__ROOT__的值为tp框架所在的文件夹 最后包含核心框架类 以下为各种常量在本机的值(在不同的机器上有所不同)： 12345678910111213141516171819202122232425262728293031APP_DEBUG = trueAPP_PATH = \"./Application/\"MEMORY_LIMIT_ON = trueTHINK_VERSION = \"3.2.3\"URL_COMMON = 0URL_PATHINFO = 1URL_REWRITE = 2URL_COMPAT = 3EXT = \".class.php\"THINK_PATH = \"/usr/local/var/www/test/ThinkPHP/\"APP_STATUS = \"\"APP_MODE = \"common\"STORAGE_TYPE = \"File\"RUNTIME_PATH = \"./Application/Runtime/\"LIB_PATH = \"/usr/local/var/www/test/ThinkPHP/Library/\"CORE_PATH = \"/usr/local/var/www/test/ThinkPHP/Library/Think/\"BEHAVIOR_PATH = \"/usr/local/var/www/test/ThinkPHP/Library/Behavior/\"MODE_PATH = \"/usr/local/var/www/test/ThinkPHP/Mode/\"VENDOR_PATH = \"/usr/local/var/www/test/ThinkPHP/Library/Vendor/\"COMMON_PATH = \"./Application/Common/\"CONF_PATH = \"./Application/Common/Conf/\"LANG_PATH = \"./Application/Common/Lang/\"HTML_PATH = \"./Application/Html/\"LOG_PATH = \"./Application/Runtime/Logs/\"TEMP_PATH = \"./Application/Runtime/Temp/\"DATA_PATH = \"./Application/Runtime/Data/\"CACHE_PATH = \"./Application/Runtime/Cache/\"CONF_EXT = \".php\"CONF_PARSE = \"\"ADDON_PATH = \"./Application/Addon\"MAGIC_QUOTES_GPC = false 之后程序调用了Think.class.php的start()方法 0x04 实现错误与异常处理以及自动加载机制(7)123456// 注册AUTOLOAD方法spl_autoload_register('Think\\Think::autoload'); // 设定错误和异常处理register_shutdown_function('Think\\Think::fatalError');set_error_handler('Think\\Think::appError');set_exception_handler('Think\\Think::appException'); 这里有几个函数，分别来看看他们的用法： spl_autoload_register(): 注册给定的函数作为 __autoload 的实现，而__autoload会尝试加载未定义的类，实现了自动加载，以下是php.net给的官方说明 在注册自己的自动加载机制以后，TP实现了自己的致命错误处理，应用错误处理和应用异常处理机制，替换了php自己的错误处理机制 fatalError12345678910111213141516// 致命错误捕获static public function fatalError() &#123; Log::save(); if ($e = error_get_last()) &#123; switch($e['type'])&#123; case E_ERROR: case E_PARSE: case E_CORE_ERROR: case E_COMPILE_ERROR: case E_USER_ERROR: ob_end_clean(); self::halt($e); break; &#125; &#125;&#125; 调用Log::save()将错误记录到日志中 通过error_get_last函数获得最后一次发生的错误 判断错误的类型 如果是E_USER_ERROR的话通过ob_end_clean输出缓冲区内容，并且将错误信息传入halt函数，此函数为TP定义的错误输出函数 appError123456789101112131415161718192021222324252627/** * 自定义错误处理 * @access public * @param int $errno 错误类型 * @param string $errstr 错误信息 * @param string $errfile 错误文件 * @param int $errline 错误行数 * @return void */ static public function appError($errno, $errstr, $errfile, $errline) &#123; switch ($errno) &#123; case E_ERROR: case E_PARSE: case E_CORE_ERROR: case E_COMPILE_ERROR: case E_USER_ERROR: ob_end_clean(); $errorStr = \"$errstr \".$errfile.\" 第 $errline 行.\"; if(C('LOG_RECORD')) Log::write(\"[$errno] \".$errorStr,Log::ERR); self::halt($errorStr); break; default: $errorStr = \"[$errno] $errstr \".$errfile.\" 第 $errline 行.\"; self::trace($errorStr,'','NOTIC'); break; &#125; &#125; 和fatalErorr有些相像，先判断是那种类型的错误 如果是E_USER_ERROR的话，输出并清除缓冲区内容 如果设置了LOG_RECORD，则在日志文件中记录这次错误 调用halt函数将错误输出 如果不是错误而逝Notice的话，通过trace函数输出该Notice appException1234567891011121314151617181920212223/** * 自定义异常处理 * @access public * @param mixed $e 异常对象 */ static public function appException($e) &#123; $error = array(); $error['message'] = $e-&gt;getMessage(); $trace = $e-&gt;getTrace(); if('E'==$trace[0]['function']) &#123; $error['file'] = $trace[0]['file']; $error['line'] = $trace[0]['line']; &#125;else&#123; $error['file'] = $e-&gt;getFile(); $error['line'] = $e-&gt;getLine(); &#125; $error['trace'] = $e-&gt;getTraceAsString(); Log::record($error['message'],Log::ERR); // 发送404信息 header('HTTP/1.1 404 Not Found'); header('Status:404 Not Found'); self::halt($error); &#125; 当发生异常并且没有处理的时候，调用appException 获取错误信息，错误路径，获取发生错误的方法，文件，行数 在日志文件中记录当前的错误信息 向用户发送404状态码，并且输出错误信息 0x05 存储初始化(8)12// 初始化文件存储方式Storage::connect(STORAGE_TYPE); 在connect方法中，定义了一些文件的操作函数，如文件删除，追加，创建，读取等 0x06 缓存文件的定义与获取以及DEBUG模式的文件加载(9～22)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980$runtimefile = RUNTIME_PATH.APP_MODE.'~runtime.php';if(!APP_DEBUG &amp;&amp; Storage::has($runtimefile))&#123; Storage::load($runtimefile);&#125;else&#123; if(Storage::has($runtimefile)) Storage::unlink($runtimefile); $content = ''; // 读取应用模式 $mode = include is_file(CONF_PATH.'core.php')?CONF_PATH.'core.php':MODE_PATH.APP_MODE.'.php'; // 加载核心文件 foreach ($mode['core'] as $file)&#123; if(is_file($file)) &#123; include $file; if(!APP_DEBUG) $content .= compile($file); &#125; &#125; // 加载应用模式配置文件 foreach ($mode['config'] as $key=&gt;$file)&#123; is_numeric($key)?C(load_config($file)):C($key,load_config($file)); &#125; // 读取当前应用模式对应的配置文件 if('common' != APP_MODE &amp;&amp; is_file(CONF_PATH.'config_'.APP_MODE.CONF_EXT)) C(load_config(CONF_PATH.'config_'.APP_MODE.CONF_EXT)); // 加载模式别名定义 if(isset($mode['alias']))&#123; self::addMap(is_array($mode['alias'])?$mode['alias']:include $mode['alias']); &#125; // 加载应用别名定义文件 if(is_file(CONF_PATH.'alias.php')) self::addMap(include CONF_PATH.'alias.php'); // 加载模式行为定义 if(isset($mode['tags'])) &#123; Hook::import(is_array($mode['tags'])?$mode['tags']:include $mode['tags']); &#125; // 加载应用行为定义 if(is_file(CONF_PATH.'tags.php')) // 允许应用增加开发模式配置定义 Hook::import(include CONF_PATH.'tags.php'); // 加载框架底层语言包 L(include THINK_PATH.'Lang/'.strtolower(C('DEFAULT_LANG')).'.php'); if(!APP_DEBUG)&#123; $content .= \"\\nnamespace &#123;Think\\\\Think::addMap(\".var_export(self::$_map,true).\");\"; $content .= \"\\nL(\".var_export(L(),true).\");\\nC(\".var_export(C(),true).');Think\\Hook::import('.var_export(Hook::get(),true).');&#125;'; Storage::put($runtimefile,strip_whitespace('&lt;?php '.$content)); &#125;else&#123;// 调试模式加载系统默认的配置文件C(include THINK_PATH.'Conf/debug.php');// 读取应用调试配置文件if(is_file(CONF_PATH.'debug'.CONF_EXT)) C(include CONF_PATH.'debug'.CONF_EXT); &#125;&#125;// 读取当前应用状态对应的配置文件if(APP_STATUS &amp;&amp; is_file(CONF_PATH.APP_STATUS.CONF_EXT)) C(include CONF_PATH.APP_STATUS.CONF_EXT); // 设置系统时区date_default_timezone_set(C('DEFAULT_TIMEZONE'));// 检查应用目录结构 如果不存在则自动创建if(C('CHECK_APP_DIR')) &#123; $module = defined('BIND_MODULE') ? BIND_MODULE : C('DEFAULT_MODULE'); if(!is_dir(APP_PATH.$module) || !is_dir(LOG_PATH))&#123; // 检测应用目录结构 Build::checkDir($module); &#125;&#125;// 记录加载文件时间G('loadTime');// 运行应用App::run(); 定义$runtimefile的目录:./Application/Runtime/common~runtime.php 如果不是DEBUG模式并且存在缓存文件的话，直接加载缓存文件 如果是DEBUG模式，如果缓存文件存在的话则删除 读取当前应用模式，默认为普通模式，由APP_MODE定义，当前为普通模式 加载类型别名定义，实际上是将命名空间映射成对应文件的绝对路径 加载模式行为定义 加载底层语言包 加载调试模式的配置文件 判断应用状态并读取状态配置文件(如果APP_STATUS常量定义不为空的话) 调用App::run()运行应用 0x06 运行应用1234567891011121314151617static public function run() &#123; // 应用初始化标签 Hook::listen('app_init'); App::init(); // 应用开始标签 Hook::listen('app_begin'); // Session初始化 if(!IS_CLI)&#123; session(C('SESSION_OPTIONS')); &#125; // 记录应用初始化时间 G('initTime'); App::exec(); // 应用结束标签 Hook::listen('app_end'); return ; &#125; 应用初始化函数：App::init()123456789101112131415161718192021222324252627282930313233343536373839/** * 应用程序初始化 * @access public * @return void */static public function init() &#123;// 加载动态应用公共文件和配置load_ext_file(COMMON_PATH);// 日志目录转换为绝对路径 默认情况下存储到公共模块下面C('LOG_PATH', realpath(LOG_PATH).'/Common/');// 定义当前请求的系统常量define('NOW_TIME', $_SERVER['REQUEST_TIME']);define('REQUEST_METHOD',$_SERVER['REQUEST_METHOD']);define('IS_GET',REQUEST_METHOD =='GET' ? true : false);define('IS_POST', REQUEST_METHOD =='POST' ? true : false);define('IS_PUT',REQUEST_METHOD =='PUT' ? true : false);define('IS_DELETE', REQUEST_METHOD =='DELETE' ? true : false);// URL调度Dispatcher::dispatch();if(C('REQUEST_VARS_FILTER'))&#123; // 全局安全过滤 array_walk_recursive($_GET, 'think_filter'); array_walk_recursive($_POST, 'think_filter'); array_walk_recursive($_REQUEST, 'think_filter'); &#125;// URL调度结束标签Hook::listen('url_dispatch'); define('IS_AJAX', ((isset($_SERVER['HTTP_X_REQUESTED_WITH']) &amp;&amp; strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) == 'xmlhttprequest') || !empty($_POST[C('VAR_AJAX_SUBMIT')]) || !empty($_GET[C('VAR_AJAX_SUBMIT')])) ? true : false);// TMPL_EXCEPTION_FILE 改为绝对地址C('TMPL_EXCEPTION_FILE',realpath(C('TMPL_EXCEPTION_FILE')));return ;&#125; TP的应用初始化可以分为以下几个阶段： 加载动态应用的文件和配置(8) 设置日志文件的绝对路径(11) URL调度(13~34) 设置异常页面的模板文件(37) 应用开始函数：App::exec() 如果不是CLI环境的话，设置session 进入App::exec()函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static public function exec() &#123; if(!preg_match('/^[A-Za-z](\\/|\\w)*$/',CONTROLLER_NAME))&#123; // 安全检测 $module = false; &#125;elseif(C('ACTION_BIND_CLASS'))&#123; // 操作绑定到类：模块\\Controller\\控制器\\操作 $layer = C('DEFAULT_C_LAYER'); if(is_dir(MODULE_PATH.$layer.'/'.CONTROLLER_NAME))&#123; $namespace = MODULE_NAME.'\\\\'.$layer.'\\\\'.CONTROLLER_NAME.'\\\\'; &#125;else&#123; // 空控制器 $namespace = MODULE_NAME.'\\\\'.$layer.'\\\\_empty\\\\'; &#125; $actionName = strtolower(ACTION_NAME); if(class_exists($namespace.$actionName))&#123; $class = $namespace.$actionName; &#125;elseif(class_exists($namespace.'_empty'))&#123; // 空操作 $class = $namespace.'_empty'; &#125;else&#123; E(L('_ERROR_ACTION_').':'.ACTION_NAME); &#125; $module = new $class; // 操作绑定到类后 固定执行run入口 $action = 'run'; &#125;else&#123; //创建控制器实例 $module = controller(CONTROLLER_NAME,CONTROLLER_PATH); &#125; if(!$module) &#123; if('4e5e5d7364f443e28fbf0d3ae744a59a' == CONTROLLER_NAME) &#123; header(\"Content-type:image/png\"); exit(base64_decode(App::logo())); &#125; // 是否定义Empty控制器 $module = A('Empty'); if(!$module)&#123; E(L('_CONTROLLER_NOT_EXIST_').':'.CONTROLLER_NAME); &#125; &#125; // 获取当前操作名 支持动态路由 if(!isset($action))&#123; $action = ACTION_NAME.C('ACTION_SUFFIX'); &#125; try&#123; self::invokeAction($module,$action); &#125; catch (\\ReflectionException $e) &#123; // 方法调用发生异常后 引导到__call方法处理 $method = new \\ReflectionMethod($module,'__call'); $method-&gt;invokeArgs($module,array($action,'')); &#125; return ; &#125; 对传入的控制器进行安全检查 判断是否有ACTION_BIND_CLASS配置 调用controller方法创建控制器实例 如果为空控制器，则显示Logo 如果没有动作的话，取出默认动作 最后调用invokeAction执行$module类中的$action方法（此处利用了php的反射机制） 到这里基本整个TP框架的初始化就完成了，接下来就是去依次根据路由执行各个控制器的方法 总结在之前分析一些框架的时候，函数老是跳来跳去的，就把自己跟乱了，这次分析一边TP框架，每个框架都有他们相同的地方，现在大多数框架都是MVC模式，这些框架中的一般都会有URL调度，错误异常处理，DEBUG模式，缓存加载等通用的技术，可能实现的语言不同，但是逻辑和原理并不会差太多。 基本TP框架的流程可以大体上分为三个： TP框架核心文件的加载和配置 应用核心文件的加载与配置 应用开始运行","categories":[],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"Vwins2.0 SQL注入漏洞分析","slug":"Vwins2.0 SQL注入漏洞分析","date":"2018-07-30T08:16:44.644Z","updated":"2018-08-01T15:36:32.332Z","comments":true,"path":"2018/07/30/Vwins2.0 SQL注入漏洞分析/","link":"","permalink":"http://yoursite.com/2018/07/30/Vwins2.0 SQL注入漏洞分析/","excerpt":"","text":"0x01 漏洞利用条件后台管理员开放注册 0x02 漏洞利用 注入点在用户名处 我们构造payload:flight&#39; and extractvalue(1,(select user()))# 可以看到我们成功执行了payload，因为前端有跳转，所以我们使用burp抓包来进行攻击 0x02 漏洞分析Vwins2.0是用CI框架搭建的，在入口文件处有着全局的过滤函数，在include config.php的时候也同时include了全局过滤类safe.php 我们看一下safe.php中的过滤 可以看到过滤了很多函数，但是好像报错函数并没有被过滤 在_construct函数中调用了本类的init()方法，我们看一下都对哪里传来的参数进行了过滤 对来自GET,POST,COOKIE,referer的信息进行了过滤 本次注入漏洞的利用点在注册用户处，因为全局过滤函数的并没有考虑到报错注入的问题，导致了漏洞的发生 根据路由我们可以定位到进行注册的函数 函数获取到post传入的username（注意:username在最开始就已经被过滤一次了，而且还过滤了一次xss，但是不影响sql执行），将其存在$_arr[&#39;username&#39;]中，我们继续跟踪username，发现在117行调用了了ddb的get_total方法，跟踪这个方法 发现在94行进行了sql的拼接，进入where_preg 最后拼接后的sql语句为：SELECT COUNT(*) AS num FROM es_users WHERE &#39;username&#39; = &#39;flight&#39; 因为union select被过滤，我们可以使用extractvalue来报错注入，即可构造payload：flight&#39; and extractvalue(1,(select user()))#","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"ci","slug":"ci","permalink":"http://yoursite.com/tags/ci/"}]},{"title":"实例化漏洞和XXE","slug":"实例化任意对象漏洞","date":"2018-07-28T06:32:05.186Z","updated":"2018-07-29T03:33:57.686Z","comments":true,"path":"2018/07/28/实例化任意对象漏洞/","link":"","permalink":"http://yoursite.com/2018/07/28/实例化任意对象漏洞/","excerpt":"","text":"一道实例化漏洞和XXE结合的题题目源码1234567891011121314151617181920212223//index.php&lt;?phpshow_source(__FILE__);class NotFound&#123; function __construct() &#123; die('404'); &#125;&#125;spl_autoload_register( function ($class)&#123; new NotFound(); &#125;);$classname = isset($_GET['name']) ? $_GET['name'] : null;$param = isset($_GET['param']) ? $_GET['param'] : null;$param2 = isset($_GET['param2']) ? $_GET['param2'] : null;if(class_exists($classname))&#123; $newclass = new $classname($param,$param2); var_dump($newclass); foreach ($newclass as $key=&gt;$value) echo $key.'=&gt;'.$value.'&lt;br&gt;';&#125; 1234//flag13Here.php&lt;?php$flag = \"HRCTF&#123;X33_W1tH_S1mpl3Xml3l3m3nt&#125;\";?&gt; 解法分析先看可控的点： 有三个get参数的点可以控制，分别是$classname,$param,$param2 再往后看，$classname可以让我们实例化一个类，这个类是我们可控的，而且可以控制该类构造方法的前两个参数 这个地方很容易想到PHP的内置类：SimpleXMLElement，可以进行xxe攻击，但是我们现在不知道flag文件的名字，这个时候可以用PHP中的另外一个内置类：GlobIterator，可以列出来所有匹配的文件名（这个类有点像glob://协议）： 根据文档，很容易理解GlobIterator类的构造方式，而第二个参数控制的是输出的键值，可以选择0，所以构造payload： ?name=GlobIterator&amp;param1=./*.php&amp;param2=0 发现成功读出当前目录的文件 现在已经知道了flag的文件名，那么我们可以构造SimpleXMLElement类来进行XXE来读取flag文件的内容 先看一下SimpleXMLElement的构造方法 第一个参数可以是XML的文件路径，可以是XML文件内容，也可以是URL（需要第三个参数为true） 第二个参数为系统预定义的常量，具体的意义如下： 为了避免一些特殊字符的错误，我们将结果进行base64编码： 构造payload为：name=SimpleXMLElement&amp;param=/Library/WebServer/Documents/PhpProjects/CTF_php/flag13Here.php&amp;param2=2 即可读取到结果：","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"安全技术","slug":"安全技术","permalink":"http://yoursite.com/tags/安全技术/"}]},{"title":"OneThink CMS的缓存漏洞的分析","slug":"OneThink CMS的缓存漏洞的分析","date":"2018-07-27T14:50:39.716Z","updated":"2018-07-28T12:15:29.088Z","comments":true,"path":"2018/07/27/OneThink CMS的缓存漏洞的分析/","link":"","permalink":"http://yoursite.com/2018/07/27/OneThink CMS的缓存漏洞的分析/","excerpt":"","text":"第一次分析漏洞，跟着其他师傅的分析过程自己走了一遍，有的地方不太懂也查清楚了，写一遍加深记忆吧 0x01 漏洞利用条件 OneThink1.0 并且/Temp/Runtime目录可读可写 0x02 漏洞分析因为TP对缓存设计逻辑的漏洞，以及缓存文件名可猜测的原因，导致了这个漏洞 先看一下TP的缓存文件的配置： TP中一些系统常量的定义都在ThinkPHP/ThinkPHP.php中定义，缓存路径也在这里： 可以看到其中的TEMP_PATH默认值为Runtime/Temp目录 而缓存文件存储的位置在ThinkPHP/Conf/convention.php 我们开始从登陆开始一步步分析OneThink在登陆的时候缓存文件是如何存储的： 在抓包以后，我们发现请求的地址为/home/user/login.html，那么跟踪这个请求，我们可以定位到Home模块的UserController控制器中的login方法： 其中在登陆成功以后调用了$Member中的login方法，传入的$uid是从数据库中查询出来的用户名对应的用户id 其中的D函数是TP中获取model的方法，这里相当于获得了一个MemberModel类的实例，我们进入MemberModel中查看一下其中的login函数 其中的$user是从$uid中拿到的，也就是用户名 在登陆用户的时候调用了autoLogin函数，进入这个函数里面查看 里面调用了get_username函数，继续跟入 终于找到了对于用户名的缓存操作 在第一次登陆的时候是没有缓存的，if条件应该直接进入else部分，又因为$list是从$uid所在行的第二行拿到的，所以应该是用户名，所以在下面调用S方法缓存数据的时候传入的$list我们是可控的 再进入S函数，查看一下这个函数的具体设计 我们传入的$list就是S函数中的value参数，分析if条件的话可以知道程序直接进入第二个elseif，初始化$cache，关键在最后的set函数，set函数中的$value仍然是我们可控的，进入set函数中，set函数在ThinkPHP/Library/Think/Cache/Driver/File.class.php 发现$filename被file_put_contents直接调用，如果不开启数据压缩的话，$data则是我们控制的$value序列化以后存入的值 现在我们可以控制文件中的一部分内容，知道了文件存储的目录，如果我们知道文件名就好了，那么我们进入filename函数里面看一下缓存文件的文件名是怎么定义的 因为一般没有开启DATA_CACHE_SUBDIR，所以判断直接跳到else部分，而options[‘prefix’]是空的，所以最后的文件名为md5($name).php 现在我们构造payload： 用户名注册为%0aphpinfo();#这样在存储缓存文件的时候就可以写入webshell，#注释了序列化的剩余部分，前面的%0a的作用则是为了不让$data中&lt;?php\\n//&quot;.sprintf(&#39;%012d&#39;,$expire).$check.$data.&quot;\\n?&gt;的’//‘注释攻击代码 0x03 漏洞利用在OneThink的注册页面中的注册用户名为:%0aphpinfo();#，并且用burp抓包将%0a解码 之后用这个用户名登陆，同样抓包将%0a解码，之后访问Temp/Runtime/用户名md5.php，即可发现phpinfo得以执行 查看缓存文件的内容，可以发现payload的原理： 0x04 总结这是第一次这么系统的分析一个漏洞，可以说学到了很多，最近也在学TP框架，正好也是一个巩固和提高，虽然是跟着别人的路走的，但是仍然很艰难，可能是第一次分析漏洞吧，这是第一次，但不是最后一次，希望下次能更游刃有余吧","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"}]}]}