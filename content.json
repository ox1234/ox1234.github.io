{"meta":{"title":"技术改变世界，文化改变人心","subtitle":"一个专注于web安全的web狗","description":null,"author":"flight","url":"http://yoursite.com"},"pages":[{"title":"links","date":"2018-07-26T14:57:21.000Z","updated":"2018-08-05T09:05:12.558Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"double-r’s blog pupil’s blog qiqi’s blog quincy’s blog void0red’s blog koocola’s blog 欣佬’s blog"},{"title":"关于我","date":"2018-07-25T02:02:28.000Z","updated":"2018-07-26T14:36:42.501Z","comments":true,"path":"whoami/index.html","permalink":"http://yoursite.com/whoami/index.html","excerpt":"","text":"专注于web安全，热爱一切美的东西，喜欢音乐，喜欢吉他，喜欢尝试新的东西，在计算机这条深不见底的洞里面越走越远，估计是脱不了坑了 身边有一堆大佬朋友还是很靠谱的，给一些各位神的链接"}],"posts":[{"title":"MetInfo SQL注入漏洞详解","slug":"MetInfo SQL注入漏洞详解","date":"2018-10-17T03:17:26.454Z","updated":"2018-10-17T10:51:06.783Z","comments":true,"path":"2018/10/17/MetInfo SQL注入漏洞详解/","link":"","permalink":"http://yoursite.com/2018/10/17/MetInfo SQL注入漏洞详解/","excerpt":"","text":"MetInfo SQL注入漏洞详解前言之前CNVD爆出了一个最新版本的MetInfoSQL注入漏洞，根据payload正向分析了一遍漏洞原理，写一篇详细一点的 参数回溯payload: admin/index.php?m=web&amp;n=message&amp;c=message&amp;a=domessage&amp;action=add&amp;lang=cn&amp;para137=1&amp;para186=1&amp;para138=1&amp;para139=1&amp;para140=1&amp;id=42 and 1=1 需要在管理员页面触发，为一个bool类型的SQL盲注 问题出现在/app/message/web/message.class.php中的add函数 12345678910111213141516//message类public function add($info) &#123; global $_M; if(!$_M[form][id])&#123; $message=DB::get_one(\"select * from &#123;$_M[table][column]&#125; where module= 7 and lang ='&#123;$_M[form][lang]&#125;'\"); $_M[form][id]=$message[id]; &#125; $met_fd_ok=DB::get_one(\"select * from &#123;$_M[table][config]&#125; where lang ='&#123;$_M[form][lang]&#125;' and name= 'met_fd_ok' and columnid = &#123;$_M[form][id]&#125;\"); $_M[config][met_fd_ok]= $met_fd_ok[value]; if(!$_M[config][met_fd_ok])okinfo('javascript:history.back();',\"&#123;$_M[word][Feedback5]&#125;\"); if($_M[config][met_memberlogin_code])&#123; if(!load::sys_class('pin', 'new')-&gt;check_pin($_M['form']['code']))&#123; okinfo(-1, $_M['word']['membercode']); &#125; &#125; 可以看到在第七行处的$_M[form][id]并没有被单引号包裹，出现了SQL注入漏洞，我们再回溯变量看看$_M[form][id]是从哪里来的，可以看到第二行定义了全局变量$_M 123456//message类public function __construct() &#123; global $_M; parent::__construct(); $this-&gt;upfile = load::sys_class('upfile', 'new'); &#125; 并且在message的构造方法中也定义了$_M，且未初始化，判断$_M在message的构造方法中被赋值，在构造方法中还调用了父类的__construct方法 12345678910111213141516//web类public function __construct() &#123; parent::__construct(); global $_M; // 可视化窗口语言栏跳转后，整个可视化页面跳转到新语言 if(strpos($_SERVER['HTTP_REFERER'], 'pageset=1')!==false &amp;&amp; strpos($_SERVER['HTTP_REFERER'], 'lang=')!==false &amp;&amp; strpos($_SERVER['HTTP_REFERER'], $_M['url']['site'])!==false)&#123; preg_match('/lang=(\\w+)/', $_SERVER['HTTP_REFERER'], $prev_lang); if($prev_lang &amp;&amp; $prev_lang[1] !=$_M['lang'])&#123; $new_url=\"&#123;$_M['url']['site_admin']&#125;index.php?lang=&#123;$_M['lang']&#125;&amp;n=ui_set&amp;pageset=1\"; echo \"&lt;script&gt; parent.document.getElementsByClassName('page-iframe')[0].setAttribute('data-dynamic','&#123;$_M['url']['site']&#125;index.php?lang=&#123;$_M['lang']&#125;'); parent.window.location.href='&#123;$new_url&#125;'; &lt;/script&gt;\"; die; &#125; &#125; 在web类的构造方法中并没有发现对$_M的赋值操作，而且web类又调用了父类的构造方法，继续回溯web类父类的构造方法 123456789101112//common类public function __construct() &#123; global $_M;//全局数组$_M ob_start();//开启缓存 $this-&gt;load_mysql();//数据库连接 $this-&gt;load_form();//表单过滤 $this-&gt;load_lang();//加载语言配置 $this-&gt;load_config_global();//加载全站配置数据 $this-&gt;load_url_site(); $this-&gt;load_config_lang();//加载当前语言配置数据 $this-&gt;load_url();//加载url数据 &#125; 在这里的load_form函数中对传入的GPC参数进行了过滤和赋值，并且将处理过的GPC转存到$_M中 至此，我们找到了$_M赋值的地方，此时类的继承关系为：common-&gt;web-&gt;message 123456789101112131415161718192021222324252627protected function load_form() &#123; global $_M; $_M['form'] =array(); isset($_REQUEST['GLOBALS']) &amp;&amp; exit('Access Error'); foreach($_COOKIE as $_key =&gt; $_value) &#123; $_key&#123;0&#125; != '_' &amp;&amp; $_M['form'][$_key] = daddslashes($_value); &#125; foreach($_POST as $_key =&gt; $_value) &#123; $_key&#123;0&#125; != '_' &amp;&amp; $_M['form'][$_key] = daddslashes($_value); &#125; foreach($_GET as $_key =&gt; $_value) &#123; $_key&#123;0&#125; != '_' &amp;&amp; $_M['form'][$_key] = daddslashes($_value); &#125; if(is_numeric($_M['form']['lang']))&#123;//伪静态兼容 $_M['form']['page'] = $_M['form']['lang']; $_M['form']['lang'] = ''; &#125; if($_M['form']['metid'] == 'list')&#123; $_M['form']['list'] = 1; $_M['form']['metid'] = $_M['form']['page']; $_M['form']['page'] = 1; &#125; if(!preg_match('/^[0-9A-Za-z]+$/', $_M['form']['lang']) &amp;&amp; $_M['form']['lang'])&#123; echo \"No data in the database,please reinstall.\"; die(); &#125; &#125; 在load_form函数中我们发现了赋值给$_M的过程和过滤函数daddslashes，跟入查看 1234567891011121314151617181920212223/** * 对字符串进行反斜杠处理，如果服务器开启MAGIC_QUOTES_GPC。则不处理。 * @param string/array $string 处理的字符串或数组 * @param bool $force 是否强制反斜杠处理 * @return array 返回处理好的字符串或数组 */function daddslashes($string, $force = 0) &#123; !defined('MAGIC_QUOTES_GPC') &amp;&amp; define('MAGIC_QUOTES_GPC', get_magic_quotes_gpc()); if(!MAGIC_QUOTES_GPC || $force) &#123; if(is_array($string)) &#123; foreach($string as $key =&gt; $val) &#123; $string[$key] = daddslashes($val, $force); &#125; &#125; else &#123; if(!defined('IN_ADMIN'))&#123; $string = trim(addslashes(sqlinsert($string))); &#125;else&#123; $string = trim(addslashes($string)); &#125; &#125; &#125; return $string;&#125; 在没有定义IN_ADMIN的时候在addslashes之前还调用了sqlinsert函数，这也就是为什么作者说在第一次尝试注入的时候发现SQL关键词都被清除了，所以我们需要找到一个地方定义了IN_ADMIN来绕过sqlinsert函数 正向分析即然我们需要IN_ADMIN值不为false，根据字面意思判断，就可以知道需要在管理页面找，而admin/index.php正好定义了IN_ADMIN的值 而且在此文件中我们可以更改GET参数来调用各种模型，类名，操作名(操作名必须以do开头) 作者找到了domessage函数可以触发add方法，并且将GET的参数全部传递过去，成功注入，鉴于里面的逻辑太复杂，直接使用xdebug跟踪函数调用 输入payload之后直接跟到调用add函数的位置，可以在PHPstorm中看到所有的函数调用关系 在_load_class中实例化了message类 在实例化的时候调用message类的构造方法，调用了message父类web的父类common的构造方法，并且使用了load_form过滤了传入的GPC参数，这个地方在跟踪的时候发现居然跳到了web类中实现的load_form函数，刚开始有点迷，后来想清楚了 在学面向对象的时候继承是一个很重要的概念，而这个时候就是面向对象的一个特性，此时调用方法是：$this-&gt;load_form();//表单过滤，可以看到当前的\\$this指向的是message类，这个时候去message类找load_form()函数，发现没有这个函数，根据继承的特性，程序向message类的父类去找load_form()函数，发现它的父类实现了load_form，所以直接调用message父类的load_form，而这个函数 12345678910111213141516171819202122/** * 重写common类的load_form方法，前台对提交的GET，POST，COOKIE进行安全的过滤处理 */ protected function load_form() &#123; global $_M; parent::load_form(); foreach ($_M['form'] as $key =&gt; $val) &#123; $_M['form'][$key] = sqlinsert($val); &#125; if ($_M['form']['id']!='' &amp;&amp; !is_numeric($_M['form']['id'])) &#123; $_M['form']['id'] = ''; &#125; if ($_M['form']['class1']!='' &amp;&amp; !is_numeric($_M['form']['class1'])) &#123; $_M['form']['class1'] = ''; &#125; if ($_M['form']['class2']!='' &amp;&amp; !is_numeric($_M['form']['class2'])) &#123; $_M['form']['class2'] = ''; &#125; if ($_M['form']['class3']!='' &amp;&amp; !is_numeric($_M['form']['class3'])) &#123; $_M['form']['class3'] = ''; &#125; &#125; 可以看到这里对每一个table传入的参数进行一次sqlinsert过滤，按理来说我们的payload已经被过滤了，通过监视$_M，确实我们的payload已经为空了 但是为什么我们的payload最后还能执行呢，再跟踪函数，我发现在调用完web类的load_form函数之后，调用了$this-&gt;upfile = load::sys_class(&#39;upfile&#39;, &#39;new&#39;);，在这个函数中又重新调用了common的构造方法，结果把payload又赋值给了$_M 这个时候我们的payload又回到了$_M的id参数中 这个时候，可以确定payload可以拼接入SQL语句中，但是接下来还需要将所有逻辑走通，接下来解答几个问题 为什么需要paraXXX参数在执行domessage函数的时候，可以看到在执行add函数之前执行了一个check_field函数，我们进入查看 123456789101112131415161718192021222324252627282930313233343536function check_field()&#123; global $_M; $messagecfg= load::mod_class('message/message_handle','new')-&gt;get_message_config(load::mod_class('message/message_database','new')-&gt;get_message_columnid()); $met_message_fd_class=$_M[form]['para'.$messagecfg[met_message_fd_class][value]]; $met_message_fd_content=$_M[form]['para'.$messagecfg[met_message_fd_content][value]]; $met_message_fd_email=$_M[form]['para'.$messagecfg[met_message_fd_email][value]]; $met_message_fd_sms=$_M[form]['para'.$messagecfg[met_message_fd_sms][value]]; $met_fd_back=$messagecfg[met_fd_back][value]; $paralist=load::mod_class('parameter/parameter_database','new')-&gt;get_parameter('7'); foreach ($paralist as $key =&gt; $val) &#123; $para[$val[id]]=$val; &#125; $paraarr = array(); foreach (array_keys($_M['form']) as $vale) &#123; if (strstr($vale, 'para')) &#123; if (strstr($vale, '_')) &#123; $arr = explode('_',$vale); $paraarr[] = str_replace('para','',$arr[0]); &#125;else&#123; $paraarr[] = str_replace('para','',$vale); &#125; &#125; &#125; foreach (array_keys($para) as $val) &#123; if($para[$val]['wr_ok']==1 &amp;&amp; !in_array($val,$paraarr))&#123; $info=\"【&#123;$para[$val]['name']&#125;】\".$_M[word][noempty]; okinfo('javascript:history.back();',$info); &#125; &#125; //met_message_fd_class 姓名 //met_message_fd_content 留言内容 //met_message_fd_email 邮箱 // met_message_fd_sms 电话 &#125; 下面这些变量就是我们传入参数中paraXXX的内容： 12345$met_message_fd_class=$_M[form]['para'.$messagecfg[met_message_fd_class][value]];$met_message_fd_content=$_M[form]['para'.$messagecfg[met_message_fd_content][value]];$met_message_fd_email=$_M[form]['para'.$messagecfg[met_message_fd_email][value]];$met_message_fd_sms=$_M[form]['para'.$messagecfg[met_message_fd_sms][value]];$met_fd_back=$messagecfg[met_fd_back][value]; 这一行if($para[$val][&#39;wr_ok&#39;]==1 &amp;&amp; !in_array($val,$paraarr))判断了我们传入的参数中有无paraXXX 我们需要在传入的参数中有137,186,138,139,140，否则会进入if条件中的逻辑 12$info=\"【&#123;$para[$val]['name']&#125;】\".$_M[word][noempty];okinfo('javascript:history.back();',$info); 为什么id必须为42123$met_fd_ok=DB::get_one(\"select * from &#123;$_M[table][config]&#125; where lang ='&#123;$_M[form][lang]&#125;' and name= 'met_fd_ok' and columnid = &#123;$_M[form][id]&#125;\");$_M[config][met_fd_ok]= $met_fd_ok[value];if(!$_M[config][met_fd_ok])okinfo('javascript:history.back();',\"&#123;$_M[word][Feedback5]&#125;\"); 可以看到，从数据库中取出$_met_fd_ok的值，如果$_met_fd_ok[value]不为空的话，继续往下执行，我们进入数据库看看这条语句到底取出来的是哪些值 可以看到我们想让它的返回不为空，id的值必须为42或者44，所以我们的注入的时候必须保证id的值为44或者42 总结metinfo的SQL注入漏洞是作者在几次给metinfo提交后met官方不予理睬才曝光的，希望厂商能多多重视安全吧","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"安全技术","slug":"安全技术","permalink":"http://yoursite.com/tags/安全技术/"}]},{"title":"TP框架源码分析","slug":"TP框架源码分析","date":"2018-10-14T15:49:10.450Z","updated":"2018-10-17T10:43:23.377Z","comments":true,"path":"2018/10/14/TP框架源码分析/","link":"","permalink":"http://yoursite.com/2018/10/14/TP框架源码分析/","excerpt":"","text":"TP框架源码分析TP框架执行流程图接下来几篇文章，通过xdebug的单步调试一步一步分析TP框架的源码，搞清楚他的框架实现，以及一些错误，异常，钩子等等的手法，看看我们的请求到底在TP内部产生了哪些变化 0x01 记录内存使用(4)12345// 记录开始运行时间$GLOBALS['_beginTime'] = microtime(TRUE);// 记录内存初始使用define('MEMORY_LIMIT_ON',function_exists('memory_get_usage'));if(MEMORY_LIMIT_ON) $GLOBALS['_startUseMems'] = memory_get_usage(); microtime — 返回当前 Unix 时间戳和微秒数 第2，3行判断了memory_get_usage方法是否存在，如果存在的话则调用memory_get_usage方法得到系统为php分配的内存，并且在全局变量中注册，下图为当前各变量的值和状态 0x02 各种常量定义(5) 定义了各种不同的url模式，在配置文件中可以更改 定义了类文件的后缀名为.class.php 定义了一些路径常量 THINK_PATH: /usr/local/var/www/test/ThinkPHP/ TP框架各种核心文件的根目录 LIB_PATH: /usr/local/var/www/test/ThinkPHP/Library/ 类库目录 APP_PATH: ./Application/ 应用目录 COMMON_PATH: ./Application/Common/ 应用公共目录 RUNTIME_PATH: ./Application/Runtime/ 应用运行目录 判断是否为SAE环境，如果不是为普通模式，存储类型默认为FILE 定义各种核心类库，运行时目录等等在运行时需要的路径常量，都是与之前的路径常量拼接得到的 0x03 对运行环境的判断123456789101112131415161718192021222324252627282930// 系统信息if(version_compare(PHP_VERSION,'5.4.0','&lt;')) &#123; ini_set('magic_quotes_runtime',0); define('MAGIC_QUOTES_GPC',get_magic_quotes_gpc()? true : false);&#125;else&#123; define('MAGIC_QUOTES_GPC',false);&#125;define('IS_CGI',(0 === strpos(PHP_SAPI,'cgi') || false !== strpos(PHP_SAPI,'fcgi')) ? 1 : 0 );define('IS_WIN',strstr(PHP_OS, 'WIN') ? 1 : 0 );define('IS_CLI',PHP_SAPI=='cli'? 1 : 0);if(!IS_CLI) &#123; // 当前文件名 if(!defined('_PHP_FILE_')) &#123; if(IS_CGI) &#123; //CGI/FASTCGI模式下 $_temp = explode('.php',$_SERVER['PHP_SELF']); define('_PHP_FILE_', rtrim(str_replace($_SERVER['HTTP_HOST'],'',$_temp[0].'.php'),'/')); &#125;else &#123; define('_PHP_FILE_', rtrim($_SERVER['SCRIPT_NAME'],'/')); &#125; &#125; if(!defined('__ROOT__')) &#123; $_root = rtrim(dirname(_PHP_FILE_),'/'); define('__ROOT__', (($_root=='/' || $_root=='\\\\')?'':$_root)); &#125;&#125;// 加载核心Think类require CORE_PATH.'Think'.EXT; 通过PHP版本和函数判断GPC是否开启，在5.4.0版本以下可以通过get_magic_quotes_gpc()来判断GPC是否开启，在5.4.0以后GPC被废除，所以直接定义MAGIC_QUOTES_GPC为false 判断PHP的SAPI是否为CGI，是否为WIN或者CLI 如果不是CLI模式，并且没有定义_PHP_FILE_的话，就定义_PHP_FILE_的值为当前脚本的路径(即为index.php入口文件的路径) 定义__ROOT__的值为tp框架所在的文件夹 最后包含核心框架类 以下为各种常量在本机的值(在不同的机器上有所不同)： 12345678910111213141516171819202122232425262728293031APP_DEBUG = trueAPP_PATH = \"./Application/\"MEMORY_LIMIT_ON = trueTHINK_VERSION = \"3.2.3\"URL_COMMON = 0URL_PATHINFO = 1URL_REWRITE = 2URL_COMPAT = 3EXT = \".class.php\"THINK_PATH = \"/usr/local/var/www/test/ThinkPHP/\"APP_STATUS = \"\"APP_MODE = \"common\"STORAGE_TYPE = \"File\"RUNTIME_PATH = \"./Application/Runtime/\"LIB_PATH = \"/usr/local/var/www/test/ThinkPHP/Library/\"CORE_PATH = \"/usr/local/var/www/test/ThinkPHP/Library/Think/\"BEHAVIOR_PATH = \"/usr/local/var/www/test/ThinkPHP/Library/Behavior/\"MODE_PATH = \"/usr/local/var/www/test/ThinkPHP/Mode/\"VENDOR_PATH = \"/usr/local/var/www/test/ThinkPHP/Library/Vendor/\"COMMON_PATH = \"./Application/Common/\"CONF_PATH = \"./Application/Common/Conf/\"LANG_PATH = \"./Application/Common/Lang/\"HTML_PATH = \"./Application/Html/\"LOG_PATH = \"./Application/Runtime/Logs/\"TEMP_PATH = \"./Application/Runtime/Temp/\"DATA_PATH = \"./Application/Runtime/Data/\"CACHE_PATH = \"./Application/Runtime/Cache/\"CONF_EXT = \".php\"CONF_PARSE = \"\"ADDON_PATH = \"./Application/Addon\"MAGIC_QUOTES_GPC = false 之后程序调用了Think.class.php的start()方法 0x04 实现错误与异常处理以及自动加载机制(7)123456// 注册AUTOLOAD方法spl_autoload_register('Think\\Think::autoload'); // 设定错误和异常处理register_shutdown_function('Think\\Think::fatalError');set_error_handler('Think\\Think::appError');set_exception_handler('Think\\Think::appException'); 这里有几个函数，分别来看看他们的用法： spl_autoload_register(): 注册给定的函数作为 __autoload 的实现，而__autoload会尝试加载未定义的类，实现了自动加载，以下是php.net给的官方说明 在注册自己的自动加载机制以后，TP实现了自己的致命错误处理，应用错误处理和应用异常处理机制，替换了php自己的错误处理机制 fatalError12345678910111213141516// 致命错误捕获static public function fatalError() &#123; Log::save(); if ($e = error_get_last()) &#123; switch($e['type'])&#123; case E_ERROR: case E_PARSE: case E_CORE_ERROR: case E_COMPILE_ERROR: case E_USER_ERROR: ob_end_clean(); self::halt($e); break; &#125; &#125;&#125; 调用Log::save()将错误记录到日志中 通过error_get_last函数获得最后一次发生的错误 判断错误的类型 如果是E_USER_ERROR的话通过ob_end_clean输出缓冲区内容，并且将错误信息传入halt函数，此函数为TP定义的错误输出函数 appError123456789101112131415161718192021222324252627/** * 自定义错误处理 * @access public * @param int $errno 错误类型 * @param string $errstr 错误信息 * @param string $errfile 错误文件 * @param int $errline 错误行数 * @return void */ static public function appError($errno, $errstr, $errfile, $errline) &#123; switch ($errno) &#123; case E_ERROR: case E_PARSE: case E_CORE_ERROR: case E_COMPILE_ERROR: case E_USER_ERROR: ob_end_clean(); $errorStr = \"$errstr \".$errfile.\" 第 $errline 行.\"; if(C('LOG_RECORD')) Log::write(\"[$errno] \".$errorStr,Log::ERR); self::halt($errorStr); break; default: $errorStr = \"[$errno] $errstr \".$errfile.\" 第 $errline 行.\"; self::trace($errorStr,'','NOTIC'); break; &#125; &#125; 和fatalErorr有些相像，先判断是那种类型的错误 如果是E_USER_ERROR的话，输出并清除缓冲区内容 如果设置了LOG_RECORD，则在日志文件中记录这次错误 调用halt函数将错误输出 如果不是错误而逝Notice的话，通过trace函数输出该Notice appException1234567891011121314151617181920212223/** * 自定义异常处理 * @access public * @param mixed $e 异常对象 */ static public function appException($e) &#123; $error = array(); $error['message'] = $e-&gt;getMessage(); $trace = $e-&gt;getTrace(); if('E'==$trace[0]['function']) &#123; $error['file'] = $trace[0]['file']; $error['line'] = $trace[0]['line']; &#125;else&#123; $error['file'] = $e-&gt;getFile(); $error['line'] = $e-&gt;getLine(); &#125; $error['trace'] = $e-&gt;getTraceAsString(); Log::record($error['message'],Log::ERR); // 发送404信息 header('HTTP/1.1 404 Not Found'); header('Status:404 Not Found'); self::halt($error); &#125; 当发生异常并且没有处理的时候，调用appException 获取错误信息，错误路径，获取发生错误的方法，文件，行数 在日志文件中记录当前的错误信息 向用户发送404状态码，并且输出错误信息 0x05 存储初始化(8)12// 初始化文件存储方式Storage::connect(STORAGE_TYPE); 在connect方法中，定义了一些文件的操作函数，如文件删除，追加，创建，读取等 0x06 缓存文件的定义与获取以及DEBUG模式的文件加载(9～22)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980$runtimefile = RUNTIME_PATH.APP_MODE.'~runtime.php';if(!APP_DEBUG &amp;&amp; Storage::has($runtimefile))&#123; Storage::load($runtimefile);&#125;else&#123; if(Storage::has($runtimefile)) Storage::unlink($runtimefile); $content = ''; // 读取应用模式 $mode = include is_file(CONF_PATH.'core.php')?CONF_PATH.'core.php':MODE_PATH.APP_MODE.'.php'; // 加载核心文件 foreach ($mode['core'] as $file)&#123; if(is_file($file)) &#123; include $file; if(!APP_DEBUG) $content .= compile($file); &#125; &#125; // 加载应用模式配置文件 foreach ($mode['config'] as $key=&gt;$file)&#123; is_numeric($key)?C(load_config($file)):C($key,load_config($file)); &#125; // 读取当前应用模式对应的配置文件 if('common' != APP_MODE &amp;&amp; is_file(CONF_PATH.'config_'.APP_MODE.CONF_EXT)) C(load_config(CONF_PATH.'config_'.APP_MODE.CONF_EXT)); // 加载模式别名定义 if(isset($mode['alias']))&#123; self::addMap(is_array($mode['alias'])?$mode['alias']:include $mode['alias']); &#125; // 加载应用别名定义文件 if(is_file(CONF_PATH.'alias.php')) self::addMap(include CONF_PATH.'alias.php'); // 加载模式行为定义 if(isset($mode['tags'])) &#123; Hook::import(is_array($mode['tags'])?$mode['tags']:include $mode['tags']); &#125; // 加载应用行为定义 if(is_file(CONF_PATH.'tags.php')) // 允许应用增加开发模式配置定义 Hook::import(include CONF_PATH.'tags.php'); // 加载框架底层语言包 L(include THINK_PATH.'Lang/'.strtolower(C('DEFAULT_LANG')).'.php'); if(!APP_DEBUG)&#123; $content .= \"\\nnamespace &#123;Think\\\\Think::addMap(\".var_export(self::$_map,true).\");\"; $content .= \"\\nL(\".var_export(L(),true).\");\\nC(\".var_export(C(),true).');Think\\Hook::import('.var_export(Hook::get(),true).');&#125;'; Storage::put($runtimefile,strip_whitespace('&lt;?php '.$content)); &#125;else&#123;// 调试模式加载系统默认的配置文件C(include THINK_PATH.'Conf/debug.php');// 读取应用调试配置文件if(is_file(CONF_PATH.'debug'.CONF_EXT)) C(include CONF_PATH.'debug'.CONF_EXT); &#125;&#125;// 读取当前应用状态对应的配置文件if(APP_STATUS &amp;&amp; is_file(CONF_PATH.APP_STATUS.CONF_EXT)) C(include CONF_PATH.APP_STATUS.CONF_EXT); // 设置系统时区date_default_timezone_set(C('DEFAULT_TIMEZONE'));// 检查应用目录结构 如果不存在则自动创建if(C('CHECK_APP_DIR')) &#123; $module = defined('BIND_MODULE') ? BIND_MODULE : C('DEFAULT_MODULE'); if(!is_dir(APP_PATH.$module) || !is_dir(LOG_PATH))&#123; // 检测应用目录结构 Build::checkDir($module); &#125;&#125;// 记录加载文件时间G('loadTime');// 运行应用App::run(); 定义$runtimefile的目录:./Application/Runtime/common~runtime.php 如果不是DEBUG模式并且存在缓存文件的话，直接加载缓存文件 如果是DEBUG模式，如果缓存文件存在的话则删除 读取当前应用模式，默认为普通模式，由APP_MODE定义，当前为普通模式 加载类型别名定义，实际上是将命名空间映射成对应文件的绝对路径 加载模式行为定义 加载底层语言包 加载调试模式的配置文件 判断应用状态并读取状态配置文件(如果APP_STATUS常量定义不为空的话) 调用App::run()运行应用 0x06 运行应用1234567891011121314151617static public function run() &#123; // 应用初始化标签 Hook::listen('app_init'); App::init(); // 应用开始标签 Hook::listen('app_begin'); // Session初始化 if(!IS_CLI)&#123; session(C('SESSION_OPTIONS')); &#125; // 记录应用初始化时间 G('initTime'); App::exec(); // 应用结束标签 Hook::listen('app_end'); return ; &#125; 应用初始化函数：App::init()123456789101112131415161718192021222324252627282930313233343536373839/** * 应用程序初始化 * @access public * @return void */static public function init() &#123;// 加载动态应用公共文件和配置load_ext_file(COMMON_PATH);// 日志目录转换为绝对路径 默认情况下存储到公共模块下面C('LOG_PATH', realpath(LOG_PATH).'/Common/');// 定义当前请求的系统常量define('NOW_TIME', $_SERVER['REQUEST_TIME']);define('REQUEST_METHOD',$_SERVER['REQUEST_METHOD']);define('IS_GET',REQUEST_METHOD =='GET' ? true : false);define('IS_POST', REQUEST_METHOD =='POST' ? true : false);define('IS_PUT',REQUEST_METHOD =='PUT' ? true : false);define('IS_DELETE', REQUEST_METHOD =='DELETE' ? true : false);// URL调度Dispatcher::dispatch();if(C('REQUEST_VARS_FILTER'))&#123; // 全局安全过滤 array_walk_recursive($_GET, 'think_filter'); array_walk_recursive($_POST, 'think_filter'); array_walk_recursive($_REQUEST, 'think_filter'); &#125;// URL调度结束标签Hook::listen('url_dispatch'); define('IS_AJAX', ((isset($_SERVER['HTTP_X_REQUESTED_WITH']) &amp;&amp; strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) == 'xmlhttprequest') || !empty($_POST[C('VAR_AJAX_SUBMIT')]) || !empty($_GET[C('VAR_AJAX_SUBMIT')])) ? true : false);// TMPL_EXCEPTION_FILE 改为绝对地址C('TMPL_EXCEPTION_FILE',realpath(C('TMPL_EXCEPTION_FILE')));return ;&#125; TP的应用初始化可以分为以下几个阶段： 加载动态应用的文件和配置(8) 设置日志文件的绝对路径(11) URL调度(13~34) 设置异常页面的模板文件(37) 应用开始函数：App::exec() 如果不是CLI环境的话，设置session 进入App::exec()函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static public function exec() &#123; if(!preg_match('/^[A-Za-z](\\/|\\w)*$/',CONTROLLER_NAME))&#123; // 安全检测 $module = false; &#125;elseif(C('ACTION_BIND_CLASS'))&#123; // 操作绑定到类：模块\\Controller\\控制器\\操作 $layer = C('DEFAULT_C_LAYER'); if(is_dir(MODULE_PATH.$layer.'/'.CONTROLLER_NAME))&#123; $namespace = MODULE_NAME.'\\\\'.$layer.'\\\\'.CONTROLLER_NAME.'\\\\'; &#125;else&#123; // 空控制器 $namespace = MODULE_NAME.'\\\\'.$layer.'\\\\_empty\\\\'; &#125; $actionName = strtolower(ACTION_NAME); if(class_exists($namespace.$actionName))&#123; $class = $namespace.$actionName; &#125;elseif(class_exists($namespace.'_empty'))&#123; // 空操作 $class = $namespace.'_empty'; &#125;else&#123; E(L('_ERROR_ACTION_').':'.ACTION_NAME); &#125; $module = new $class; // 操作绑定到类后 固定执行run入口 $action = 'run'; &#125;else&#123; //创建控制器实例 $module = controller(CONTROLLER_NAME,CONTROLLER_PATH); &#125; if(!$module) &#123; if('4e5e5d7364f443e28fbf0d3ae744a59a' == CONTROLLER_NAME) &#123; header(\"Content-type:image/png\"); exit(base64_decode(App::logo())); &#125; // 是否定义Empty控制器 $module = A('Empty'); if(!$module)&#123; E(L('_CONTROLLER_NOT_EXIST_').':'.CONTROLLER_NAME); &#125; &#125; // 获取当前操作名 支持动态路由 if(!isset($action))&#123; $action = ACTION_NAME.C('ACTION_SUFFIX'); &#125; try&#123; self::invokeAction($module,$action); &#125; catch (\\ReflectionException $e) &#123; // 方法调用发生异常后 引导到__call方法处理 $method = new \\ReflectionMethod($module,'__call'); $method-&gt;invokeArgs($module,array($action,'')); &#125; return ; &#125; 对传入的控制器进行安全检查 判断是否有ACTION_BIND_CLASS配置 调用controller方法创建控制器实例 如果为空控制器，则显示Logo 如果没有动作的话，取出默认动作 最后调用invokeAction执行$module类中的$action方法（此处利用了php的反射机制） 到这里基本整个TP框架的初始化就完成了，接下来就是去依次根据路由执行各个控制器的方法 总结在之前分析一些框架的时候，函数老是跳来跳去的，就把自己跟乱了，这次分析一边TP框架，每个框架都有他们相同的地方，现在大多数框架都是MVC模式，这些框架中的一般都会有URL调度，错误异常处理，DEBUG模式，缓存加载等通用的技术，可能实现的语言不同，但是逻辑和原理并不会差太多。 基本TP框架的流程可以大体上分为三个： TP框架核心文件的加载和配置 应用核心文件的加载与配置 应用开始运行","categories":[],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"Django开发框架(一)","slug":"Django开发框架(一)","date":"2018-08-06T06:47:55.983Z","updated":"2018-10-16T12:17:55.373Z","comments":true,"path":"2018/08/06/Django开发框架(一)/","link":"","permalink":"http://yoursite.com/2018/08/06/Django开发框架(一)/","excerpt":"","text":"Django开发框架(一)Django目录结构1234567djangosite/ manage.py djangosite/ __init__.py settings.py urls.py wsgi.py manage.py：Django用于管理本项目的命令行工具__init__：告诉python该目录是一个python包settings.py：Django的配置文件urls.py：维护项目的URL路由映射wsgi.py：定义WSGI接口信息 建立应用目录结构建立应用的命令：python manage.py startapp 应用名称 目录结构： 123456789app/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py Django的路由规则Django的路由规则由django.conf.urls中的url函数实现 在app中可以定义路由规则，在Django的urls.py中将app中定义的路由规则包含进来 urls.py–app: 1234567from django.conf.urls import urlfrom . import viewsurlpatterns = [ url(r'',views.welcome), ] urls.py–MyDjango: 12345678from django.conf.urls import urlfrom django.contrib import adminfrom django.conf.urls import includeurlpatterns = [ url(r'^app/', include('app.urls')), url(r'^admin/', admin.site.urls),] 在包含路由的时候需要导入from django.urls import include 模型类 配置项目INSTALLED_APPS 要在MyDjango项目的settings.py中告诉Django需要安装应用app中的模型，则方法是打开MyDjango/settings.py文件，找到其中的INSTALLED_APPS数组，在其中添加应用app的Config类 123456789INSTALLED_APPS = [ 'app.apps.Appconfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] 模型定义 所有的Django模型类必须继承自django.db.models 生成数据移植文件 Django的术语“生成数据移植文件”是指将models.py中定义的数据表转换为数据库生成脚本的过程，该过程由manage.py完成 命令：python manage.py makemigrations app 移植到数据库 在模型的需改过程中可以随时调用makemigrations生成中间移植文件，而当需要使移植文件生效，修改真实数据库schema时，需要manage.py的migrate命令将修改同步到数据库中 表单视图 定义表单类 1234567from django import ModelFormfrom app.models import Momentclass MomentForm(ModelForm): class Meta: model = Moment fields = '__all__' 引入django.forms.ModelForm，该类时所用Django表单类的基类 引入本应用models.py中定义的Moment类，以便在后面的表单类中关联Moment类 定义表单类MomentForm，在其中定义子类Meta，在Meta中声明与本表单关联的模型类及其字段 Fields字段可以设置为__all__，也可以用列表形式声明所要导入的属性，比如：Fields=(‘content’,’user_name’,’kind’) 修改模型类 为了使用户能够以单选的方式设置消息类型，则需要在models.py文件中定义单选枚举值，并与模型类Moment相关联 开发模版文件","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"}]},{"title":"突然有感。。。","slug":"突然想写点什么","date":"2018-08-01T15:34:28.829Z","updated":"2018-08-06T08:39:05.743Z","comments":true,"path":"2018/08/01/突然想写点什么/","link":"","permalink":"http://yoursite.com/2018/08/01/突然想写点什么/","excerpt":"","text":"突然想写点什么今天审了一天的CMS，感觉一点头绪都没有，自己一个洞都挖不出来，心态有点小崩，但是才看CMS几天，可能还需要一段时间的沉淀吧，想刚来协会的时候什么都不会，连个GET，POST请求都得看半天的我，一年时间过去，学到了很多东西，但是慢慢发现学的越多，不懂的就越多，从刚开始配置php的环境，写简单的php脚本，到现在看php的框架，看php的源码，发现自己学的越来越多，但是不懂的也越来越多，而且知识也越来越晦涩难懂，渐渐发现计算机领域实在是太庞大了，也体会到有些人为什么说计算机专业以后工作很累，当程序出错，用一天都没有找出来哪错的时候，心态真的很爆炸。因为天生喜欢这些酷酷的东西，也让我一直努力在这个方向努力，可能这些技术让我失去了一些休息时间，娱乐的时间，但是说真的自己并不觉得太亏，因为自己也获得了自己想要的。 觉得真正想要学好一个东西最重要的还是自己要有兴趣，因为有兴趣所以才可以保持激情，一直为了自己觉得酷的东西奋斗。有些人说为什么要这么累，考个公务员，拿着普通的工资，平平淡淡过一辈子不好吗？我也有过想放弃，也问过自己，为什么不让自己放松下来，每天打打游戏，和舍友玩玩王者，吃吃鸡，但是每每一想到那些优秀的学长，就觉得自己需要和他们一样，甚至比他们更好，可能我这个人太容易嫉妒别人吧，但是嫉妒有时候又何尝不是一种动力呢。 慢慢来吧，技术的提升需要时间的积淀，同样理想也需要时间的沉淀，记得有一本书上说过，人们总是长大了认为小时候的愿望不可实现，觉得那是曾经幼稚的理想，但是实际上是自己放弃了和梦想的搏斗 一年时间，说不上成功也说不上失败，以后的路还很长，和各位师傅一起加油吧！！！","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"}]},{"title":"TP框架学习笔记(常用操作)","slug":"TP框架学习笔记(常用操作)","date":"2018-08-01T06:16:53.055Z","updated":"2018-08-01T15:35:57.200Z","comments":true,"path":"2018/08/01/TP框架学习笔记(常用操作)/","link":"","permalink":"http://yoursite.com/2018/08/01/TP框架学习笔记(常用操作)/","excerpt":"","text":"session操作写入：session(&#39;key&#39;,&#39;value&#39;) 读取：session(&#39;key&#39;) 删除：session(&#39;key&#39;,null) cookie操作普通写入：cookie(&#39;name&#39;,&#39;value&#39;) 设定时间写入：cookie(&#39;name&#39;,&#39;value&#39;,7*24*3600) 读取：cookie(&#39;name&#39;) 读取所有cookie：cookie() cookie删除：cookie(&#39;name&#39;,null) 分页分页操作： 1234567$model = M('News'); //实例化News对象$count = $model -&gt; count(); //查询满足条件的总记录数$Page = new \\Think\\Page($count,30); //实例化分页类，大小为30$show = $Page.show(); //分页显示输出$list = $model-&gt;where('status=1')-&gt;order('create_time')-&gt;limit($Page-&gt;firstRow.','.$Page-&gt;listRows)-&gt;select()$this-&gt;assign('list',$list);$this-&gt;display(); 验证码用法： 12$verify = new Verify();$verify-&gt;entry(); 使用验证码有以下三步： 调用Vertify类的entry方法输出验证码图片 将img的src属性设置为第一步中的URL 接收表单提交的验证码，并调用Verify的check方法进行验证 图像处理实例化Image 12$path = './Public/images/timg.jpeg';$image = new Image(Image::IMAGE_GD,$path); 图像裁剪：crop() 图像缩略图：thum() 水印：water()","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"}]},{"title":"Vwins2.0 SQL注入漏洞分析","slug":"Vwins2.0 SQL注入漏洞分析","date":"2018-07-30T08:16:44.644Z","updated":"2018-08-01T15:36:32.332Z","comments":true,"path":"2018/07/30/Vwins2.0 SQL注入漏洞分析/","link":"","permalink":"http://yoursite.com/2018/07/30/Vwins2.0 SQL注入漏洞分析/","excerpt":"","text":"0x01 漏洞利用条件后台管理员开放注册 0x02 漏洞利用 注入点在用户名处 我们构造payload:flight&#39; and extractvalue(1,(select user()))# 可以看到我们成功执行了payload，因为前端有跳转，所以我们使用burp抓包来进行攻击 0x02 漏洞分析Vwins2.0是用CI框架搭建的，在入口文件处有着全局的过滤函数，在include config.php的时候也同时include了全局过滤类safe.php 我们看一下safe.php中的过滤 可以看到过滤了很多函数，但是好像报错函数并没有被过滤 在_construct函数中调用了本类的init()方法，我们看一下都对哪里传来的参数进行了过滤 对来自GET,POST,COOKIE,referer的信息进行了过滤 本次注入漏洞的利用点在注册用户处，因为全局过滤函数的并没有考虑到报错注入的问题，导致了漏洞的发生 根据路由我们可以定位到进行注册的函数 函数获取到post传入的username（注意:username在最开始就已经被过滤一次了，而且还过滤了一次xss，但是不影响sql执行），将其存在$_arr[&#39;username&#39;]中，我们继续跟踪username，发现在117行调用了了ddb的get_total方法，跟踪这个方法 发现在94行进行了sql的拼接，进入where_preg 最后拼接后的sql语句为：SELECT COUNT(*) AS num FROM es_users WHERE &#39;username&#39; = &#39;flight&#39; 因为union select被过滤，我们可以使用extractvalue来报错注入，即可构造payload：flight&#39; and extractvalue(1,(select user()))#","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"ci","slug":"ci","permalink":"http://yoursite.com/tags/ci/"}]},{"title":"TP框架学习笔记(模版)","slug":"TP框架学习笔记(模版)","date":"2018-07-29T03:32:51.245Z","updated":"2018-07-30T08:18:52.901Z","comments":true,"path":"2018/07/29/TP框架学习笔记(模版)/","link":"","permalink":"http://yoursite.com/2018/07/29/TP框架学习笔记(模版)/","excerpt":"","text":"变量输出在模版中输出变量语法为：&#123;&#36;val&#125; “{}”为TP模版引擎的定界符，可以通过设置：TMPL_L_DELIM和TMPL_R_DELIM来进行更改 eg: 1234array(\"TEMPL_L_DELIM\" =&gt; \"&#123;&lt;\",\"TEMPL_R_DELIM\" =&gt; \"&gt;&#125;\"); 这样配置以后输出”val”变量的语法为：&#123;&lt;&#36;val&gt;&#125; 可以通过assign函数来注册模版变量 系统变量TP支持的变量： 1234567$_SERVER$_ENV$_POST$_GET$_REQUEST$_SESSION$_COOKIE TP的模版引擎不仅支持将系统常用变量，也可以将Config.php中的数据输出 输出方式：&#123;&#36;Think.config.version&#125; 函数模版中也可以使用函数，这些函数包括： PHP内置函数 TP内置函数 用户自定义函数 类静态方法 模版中使用函数的形式为： &#123;变量|函数1|函数2…&#125; 参数大于一个函数的，比如在模版中格式化时间戳： &#123;&#36;createdAt|date=’Y-m-d H;i:s’,###&#125; 其中###为前面变量的占位符 比如将变量md5之后再截取的话： &#123;&#36;str|md5|substr=###,0,16&#125; PHP模版中嵌套函数的执行顺序是从左往右执行 变量默认值TP模版支持变量默认值，当改变量值为空的时候，显示默认值 eg: &#123;&#36;user.mark|default=’该用户什么都没写’&#125; 默认值可以和函数结合使用： eg: &#123;&#36;Think.get.name|default=”名称为空”|empty|var_dump&#125; 这句命令的意义是： 获取get方法中name参数名的内容，如果内容为空的话就赋值为default指定的值，之后判断这个值是不是empty，用var_dump打印结果 算术运算符TP中支持的算术运算符的操作包括：+,-,*,/,%,++复合运算 在使用运算符计算的时候，数组和对象都只能使用标准访问形式 模版继承父模版的布局样式子模版可以直接使用 block 在父模版中需要子模块自己实现的区块声明 extend 用来声明继承的父模版 每个区块由&lt;block&gt;&lt;/block&gt;组成，例如： &lt;block name=&quot;title&quot;&gt;&lt;title&gt;{$web_title}&lt;/title&gt;&lt;/block&gt; 还可以在区块中夹在外部文件 &lt;block name=&quot;include&quot;&gt;&lt;include file=&quot;Public:header&quot;/&gt;&lt;/block&gt; 视图包含TP中的模版文件也支持”include” 语法形式： &lt;include file=&quot;模版表达式或模版文件路径,模版表达式或模版文件路径&quot;/&gt; 模版表达式： [模块@][主题/]控制器/操作 eg: &lt;include file=Home@Mobile/Index/header&quot;/&gt; 包含文件Home/Mobile/Index/header.html 内置标签为了在模版中进行诸如”判断”,”循环”等功能，需要使用TP的标签库功能 内置标签很多，这里不一一列举，在用的时候再查啊吧 模版常量替换123456__ROOT__:当前网址（不包括域名）__APP__:当前应用的URL（不包括域名）__MODULE__:当前模块的URL（不包括域名）__ACTION__:当前操作的URL（不包括域名）__CONTROLLER__:当前控制器的URL（不包括域名）__SELF__:当前页面的URL 模版注释&#123;/&#42;注释枝内容&#42;/&#125;或&#123;//注释内容&#125;","categories":[],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"实例化漏洞和XXE","slug":"实例化任意对象漏洞","date":"2018-07-28T06:32:05.186Z","updated":"2018-07-29T03:33:57.686Z","comments":true,"path":"2018/07/28/实例化任意对象漏洞/","link":"","permalink":"http://yoursite.com/2018/07/28/实例化任意对象漏洞/","excerpt":"","text":"一道实例化漏洞和XXE结合的题题目源码1234567891011121314151617181920212223//index.php&lt;?phpshow_source(__FILE__);class NotFound&#123; function __construct() &#123; die('404'); &#125;&#125;spl_autoload_register( function ($class)&#123; new NotFound(); &#125;);$classname = isset($_GET['name']) ? $_GET['name'] : null;$param = isset($_GET['param']) ? $_GET['param'] : null;$param2 = isset($_GET['param2']) ? $_GET['param2'] : null;if(class_exists($classname))&#123; $newclass = new $classname($param,$param2); var_dump($newclass); foreach ($newclass as $key=&gt;$value) echo $key.'=&gt;'.$value.'&lt;br&gt;';&#125; 1234//flag13Here.php&lt;?php$flag = \"HRCTF&#123;X33_W1tH_S1mpl3Xml3l3m3nt&#125;\";?&gt; 解法分析先看可控的点： 有三个get参数的点可以控制，分别是$classname,$param,$param2 再往后看，$classname可以让我们实例化一个类，这个类是我们可控的，而且可以控制该类构造方法的前两个参数 这个地方很容易想到PHP的内置类：SimpleXMLElement，可以进行xxe攻击，但是我们现在不知道flag文件的名字，这个时候可以用PHP中的另外一个内置类：GlobIterator，可以列出来所有匹配的文件名（这个类有点像glob://协议）： 根据文档，很容易理解GlobIterator类的构造方式，而第二个参数控制的是输出的键值，可以选择0，所以构造payload： ?name=GlobIterator&amp;param1=./*.php&amp;param2=0 发现成功读出当前目录的文件 现在已经知道了flag的文件名，那么我们可以构造SimpleXMLElement类来进行XXE来读取flag文件的内容 先看一下SimpleXMLElement的构造方法 第一个参数可以是XML的文件路径，可以是XML文件内容，也可以是URL（需要第三个参数为true） 第二个参数为系统预定义的常量，具体的意义如下： 为了避免一些特殊字符的错误，我们将结果进行base64编码： 构造payload为：name=SimpleXMLElement&amp;param=/Library/WebServer/Documents/PhpProjects/CTF_php/flag13Here.php&amp;param2=2 即可读取到结果：","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"安全技术","slug":"安全技术","permalink":"http://yoursite.com/tags/安全技术/"}]},{"title":"TP框架学习笔记(视图)","slug":"TP框架学习笔记(视图)","date":"2018-07-28T05:49:24.907Z","updated":"2018-07-28T12:14:25.245Z","comments":true,"path":"2018/07/28/TP框架学习笔记(视图)/","link":"","permalink":"http://yoursite.com/2018/07/28/TP框架学习笔记(视图)/","excerpt":"","text":"模版定义某个模块的模版文件是独立的，默认的模版文件定义规则是： `视图目录/[模版主题]/控制器名/操作名+视图后缀 默认的视图目录是模块的View目录，框架默认的视图后缀为.html， eg: Home模块下的User控制器的add方法对应的模版文件路径为： `Application/Home/View/User/add.html 如果项目的视图不是View的话，可以通过&#39;DEFAULT_V_LAYER&#39; =&gt; &#39;Template&#39;来更改 如果需要更改后缀，可以更改： &#39;TEMPL_TEMPLATE_SUFFIX&#39; =&gt; &#39;tpl&#39; 模版主题如果某个模块要支持多个主题的话，可以使用模版主题功能 配置：&#39;DEFAULT_THEME&#39; =&gt; &#39;main&#39; 模版赋值如果要在模版中输出变量，需要在控制器中把变量传递给模版，系统提供了assign方法对变量赋值 模版渲染可以使用display函数","categories":[],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"OneThink CMS的缓存漏洞的分析","slug":"OneThink CMS的缓存漏洞的分析","date":"2018-07-27T14:50:39.716Z","updated":"2018-07-28T12:15:29.088Z","comments":true,"path":"2018/07/27/OneThink CMS的缓存漏洞的分析/","link":"","permalink":"http://yoursite.com/2018/07/27/OneThink CMS的缓存漏洞的分析/","excerpt":"","text":"第一次分析漏洞，跟着其他师傅的分析过程自己走了一遍，有的地方不太懂也查清楚了，写一遍加深记忆吧 0x01 漏洞利用条件 OneThink1.0 并且/Temp/Runtime目录可读可写 0x02 漏洞分析因为TP对缓存设计逻辑的漏洞，以及缓存文件名可猜测的原因，导致了这个漏洞 先看一下TP的缓存文件的配置： TP中一些系统常量的定义都在ThinkPHP/ThinkPHP.php中定义，缓存路径也在这里： 可以看到其中的TEMP_PATH默认值为Runtime/Temp目录 而缓存文件存储的位置在ThinkPHP/Conf/convention.php 我们开始从登陆开始一步步分析OneThink在登陆的时候缓存文件是如何存储的： 在抓包以后，我们发现请求的地址为/home/user/login.html，那么跟踪这个请求，我们可以定位到Home模块的UserController控制器中的login方法： 其中在登陆成功以后调用了$Member中的login方法，传入的$uid是从数据库中查询出来的用户名对应的用户id 其中的D函数是TP中获取model的方法，这里相当于获得了一个MemberModel类的实例，我们进入MemberModel中查看一下其中的login函数 其中的$user是从$uid中拿到的，也就是用户名 在登陆用户的时候调用了autoLogin函数，进入这个函数里面查看 里面调用了get_username函数，继续跟入 终于找到了对于用户名的缓存操作 在第一次登陆的时候是没有缓存的，if条件应该直接进入else部分，又因为$list是从$uid所在行的第二行拿到的，所以应该是用户名，所以在下面调用S方法缓存数据的时候传入的$list我们是可控的 再进入S函数，查看一下这个函数的具体设计 我们传入的$list就是S函数中的value参数，分析if条件的话可以知道程序直接进入第二个elseif，初始化$cache，关键在最后的set函数，set函数中的$value仍然是我们可控的，进入set函数中，set函数在ThinkPHP/Library/Think/Cache/Driver/File.class.php 发现$filename被file_put_contents直接调用，如果不开启数据压缩的话，$data则是我们控制的$value序列化以后存入的值 现在我们可以控制文件中的一部分内容，知道了文件存储的目录，如果我们知道文件名就好了，那么我们进入filename函数里面看一下缓存文件的文件名是怎么定义的 因为一般没有开启DATA_CACHE_SUBDIR，所以判断直接跳到else部分，而options[‘prefix’]是空的，所以最后的文件名为md5($name).php 现在我们构造payload： 用户名注册为%0aphpinfo();#这样在存储缓存文件的时候就可以写入webshell，#注释了序列化的剩余部分，前面的%0a的作用则是为了不让$data中&lt;?php\\n//&quot;.sprintf(&#39;%012d&#39;,$expire).$check.$data.&quot;\\n?&gt;的’//‘注释攻击代码 0x03 漏洞利用在OneThink的注册页面中的注册用户名为:%0aphpinfo();#，并且用burp抓包将%0a解码 之后用这个用户名登陆，同样抓包将%0a解码，之后访问Temp/Runtime/用户名md5.php，即可发现phpinfo得以执行 查看缓存文件的内容，可以发现payload的原理： 0x04 总结这是第一次这么系统的分析一个漏洞，可以说学到了很多，最近也在学TP框架，正好也是一个巩固和提高，虽然是跟着别人的路走的，但是仍然很艰难，可能是第一次分析漏洞吧，这是第一次，但不是最后一次，希望下次能更游刃有余吧","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/漏洞分析/"},{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"}]},{"title":"TP框架学习笔记(模型)","slug":"TP学习笔记(模型)","date":"2018-07-26T05:41:18.062Z","updated":"2018-07-27T14:54:24.115Z","comments":true,"path":"2018/07/26/TP学习笔记(模型)/","link":"","permalink":"http://yoursite.com/2018/07/26/TP学习笔记(模型)/","excerpt":"","text":"模型模型定义模型不是必须定义的，只有当存在额外的逻辑或者属性的时候才需要定义，TP约定的模型命名规则是去除表前缀的数据表名称，使用首字母大写的格式再加上Model eg: 数据表名称为think_user，则它的模型名称为UserModel 模型实例化 new实例化 模型本质也是PHP的类，所以可以直接用new实例化 eg: $user =new Model(&#39;User&#39;); Model类的构造方法有三个参数(去除表前缀的数据表名称，表前缀，连接配置） M函数实例化 M函数为model函数的简写，和Model类的构造方法相同 D函数实例化 D和M的区别：D函数可以自动检测模型类，如果存在指定模型类，则实例化该模型类，否则实例化”Think\\Model”类，而M函数只会实例化”Think\\Model”类 空模型实例化 如果只需要执行SQL，不需要其他操作的话，可以实例化一个空模型类 eg: 123$m = new Model(); //等效于 $m = M();$data = $m-&gt;query('SELECT * FROM c5_User');print_r($data); 连贯操作若是需要查询User模型中的status为1的前10条记录，并且按照时间倒序排序，可以通过如下代码实现 12$user = M('User');$list = $user-&gt;where('status=1')-&gt;order('create_time desc')-&gt;limit(10)-&gt;select(); 常用的支持连贯操作的方法 where: 支持字符串，数组和对象 alias: 设置当前数据表的别名 data: 用来设置当前模型需要操作的数据，未经$model-&gt;create()方法处理过的数据，TP不能直接使用 比如： 123456$model = M('User');$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');$model-&gt;add($data); 上面这一段代码会报错，因为没有经过model-&gt;create()方法处理 改为： 1234567$model = M('User');$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');$model-&gt;create($data);$model-&gt;add($data); 使用data方法： 12345$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');M('User')-&gt;data($data)-&gt;add(); field: 用来选择需要返回的字段 order: 用来排序 limit: 用来限制返回结果的数量 page: 分页操作 group: 结果分组 having: 筛选经过group分组以后且满足条件的数据集 join: 进行连表查询 CURD操作C：create，插入数据U：update，更新数据R：read，读取数据D：delete，删除数据 创建数据自动根据表单POST数据创建数据： 12$user = M('User');$user-&gt;create(); //该代码会自动读取post中的数据 从数组创建数据对象： 123456$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');$user = M('User');$user-&gt;create($data); create方法的第二个参数知指明该操作时插入还是更新操作 注：create操作产生的数据并没有真正写入数据库，而是再屌用add或者save方法以后才会操作数据库 插入数据TP插入数据使用add方法： 123456$data = array('username' =&gt; 'zhangsan','password' =&gt; '111111');$user = M('User');$user-&gt;create($data)-&gt;add(); 读取数据TP可以读取字段值，单条数据，数据集 读取字段值使用getField方法 12$model = M('User');$score = $model-&gt;where('id=3')-&gt;getField('score'); 读取单条数据使用find方法 123456//方法1:$model = M('User');$model-&gt;find(1);//方法2:$model = M('User');$model-&gt;where('id=1')-&gt;find(); 读取数据集使用select方法 12$model = M('User');$model-&gt;where('score &gt; 100')-&gt;select(); 更新数据TP中的数据更新包括更新记录和更新字段 更新记录使用save方法 123456$data = array('nickname' =&gt; 'hehe');$model = M('User');$model = create($data);$model = where('id=1').save($data); 更新字段使用setField方法 123456789//更新字段$model = M('User');$model-&gt;where('id=1')-&gt;setField('score',100);//更新统计字段$model = M('User');$model-&gt;where('id=1')-&gt;setDec('score',100);$model = M('Article');$model-&gt;where('id=1')-&gt;setInc('views',1); 删除数据使用delete方法 12$model = M('Article');$model-&gt;delete(1); 注：为了避免错删数据，如果没有任何条件进行删除操作的话，不会执行删除操作 自动验证数据验证有两种方式： 静态方式：在模型类中通过$_validate定义 动态方式：使用模型类的validate方法 验证规则： 123array( array(字段名,验证规则,错误提示,[验证条件,附加规则,验证场景])); 自动完成自动完成的两种方式： 静态方式：在模型里面通过$_auto属性定义处理机制 动态方式：使用模型类的auto方法动态创建自动处理机制 定义规则 格式： 123array(array(完成字段,完成规则,[完成条件,附加规则])); 完成字段：需要完成的字段名完成规则：以何种规则处理该字段完成条件：可自动完成的条件(self::MODEL_BOTH,self::MODEL_UPDATE,self::MODEL_INSERT) 视图模型视图一般指数据库的视图，视图是一个虚拟表，也有列和数据，视图常用来解决HAS_ONE和BELONGS_TO类型的关联查询 继承ViewModel类 配置其中的$viewFields数组 1234public $viewFields = array( 'Post' =&gt; array('post_id','title','content','created_at','updated_at'), 'User' =&gt; array('username' =&gt; 'author', '_on' =&gt; 'Post.user_id=User.id') ); 关联模型处理HAS_MANY之类的关系 关联关系包括： 一对一 一对多 多对多 HAS_ONE,BELONGS_TO,HAS_MANY,MANY_TO_MANY 要执行关联查询，模型类需要继承RelationModel，并且配置$_link属性 HAS_ONE12345678public $_link = array( 'extra' =&gt; array( 'mapping_type' =&gt; self::HAS_ONE, 'class_name' =&gt; 'UserExtra', 'foreign_key' =&gt; 'user_id', 'mapping_fields' =&gt; 'email,qq' )); BELONGS_TO1234567public $_link = array( 'author' =&gt; array( 'mapping_type' =&gt; self::BELONGS_TO, 'class_name' =&gt; 'User', 'foreign_key' =&gt; 'user_id' ));","categories":[],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"TP框架学习笔记(控制器)","slug":"TP框架学习笔记(控制器)","date":"2018-07-25T06:53:38.606Z","updated":"2018-07-26T14:30:31.311Z","comments":true,"path":"2018/07/25/TP框架学习笔记(控制器)/","link":"","permalink":"http://yoursite.com/2018/07/25/TP框架学习笔记(控制器)/","excerpt":"","text":"控制器控制器的定义控制器的作用：它起着沟通视图和模型的作用 文件名形式：xxxController.php&quot; 这里给一个例子：http://localhost/PhpProjects/thinPHP/thinkphp_3/home/test localhost是主机名 PhpProjects/thinPHP/thinkphp_3为目录路径 home为模块名 第一个test是控制器名 第二个test是动作名 当方法名为php关键字的时候，则需要配置”操作方法后缀” 配置项名称：&#39;ACTION_SUFFIX&#39; =&gt; &#39;Action&#39; 前置操作和后置操作可以通过:_before_index(),_after_index()来实现前置操作和后置操作 动作参数绑定参数绑定通过直接绑定URL地址中的变量为操作方法的形参 可以通过URL_PARAMS_BIND来开启和关闭动作参数绑定 123public function bind($id=1)&#123; echo $id;&#125; 若在IndexController.class.php中加入以上代码，即可通过访问如下的URL获取id值，而不用使用$_GET[&#39;id&#39;] eg: http://localhost/PhpProjects/thinPHP/thinkphp_3/home/index/bind/id/1 若不传入id参数，形如：http://localhost/PhpProjects/thinPHP/thinkphp_3/home/index/bind/id/ 则默认值为1 伪静态伪静态是为了优化SEO的效果，TP可以通过URL_HTML_SUFFIX来配置为静态 默认的URL_HTML_SUFFIX是以.html为后缀 设置：&#39;URL_HTML_SUFFIX&#39; =&gt; &#39;html&#39; 如果要禁止某些后缀的访问，可以通过设置URL_DENY_SUFFIX 设置：&#39;URL_DENY_SUFFIX&#39; =&gt; &#39;htm&#39; URL大小写配置项：URL_CASE_INSENSITIVE 此项配置可以实现URL不区分大小写 设置：&#39;URL_CASE_INSENSITIVE&#39; =&gt; &#39;true&#39; 设置完成以后： http://localhost/PhpProjects/thinPHP/thinkphp_3/home/index/Index http://localhost/PhpProjects/thinPHP/thinkphp_3/home/index/index 以上两个URL是等价的 URL生成TP中的U函数：U(地址表达式,参数,是否显示伪静态后缀,是否显示域名) 地址表达式： [模块/控制器/操作#锚点@域名]?参数1=值1&amp;参数2=值2... 注意：如果没有指定模块民给，则TP使用当前模块名 参数 参数支持数组和字符串形式，以下方式是等效的： U(&#39;User/View&#39;,array(&#39;id&#39;=&gt;1,&#39;role&#39;=&gt;&#39;admin&#39;)) U(&#39;User/view&#39;,&#39;id=1&amp;role=admin&#39;) 伪静态后缀 改参数为true的时候，系统读取URL_HTML_SUFFIX配置来生成URL，如果需要临时更换规则，可以直接加参数后缀名 eg: U(&#39;Blog/view&#39;,array(&#39;id&#39;=&gt;1),&#39;shtml&#39;) URL模式处理 不同的URL_MODEL会生成不同的URL Ajax返回1234567public function index()&#123; $data = array( 'status' =&gt; 1, 'data' =&gt; 'data' ); $this-&gt;ajaxReturn($data,'xml');&#125; 可以通过ajaxReturn方法来返回json或xml格式的数据 其中第二个参数为返回的数据格式 重定向和页面跳转重定向通过Controller中redirect()方法实现跳转 页面跳转通过sucess和error方法实现跳转 succes和error方法的第一个参数为提示信息，第二个参数为指向URL，第三个参数为等待时间 HTTP请求方法TP中提供了几个常量来判断HTTP请求： IS_GET,IS_POST,IS_PUT,IS_DELETE,IS_AJAX,REQUEST_METHOD 可以通过以下代码判断是否为POST或者GET方法 123456789public function login()&#123; if(IS_POST)&#123; echo '当前请求为post方法'; &#125;else if(IS_GET)&#123; echo '当前请求为get方法'; &#125;else&#123; echo '非法请求'; &#125;&#125; 读取输入TP中使用I函数来进行变量的获取和过滤 eg: echo I(&#39;post.username&#39;); == echo $_POST[&#39;username&#39;] I函数可以设置默认值，过滤方法，正则过滤 空操作当TP找不到请求的操作的时候，会执行_empty方法 在控制器中添加_empty方法可以实现对错误界面的优化 空控制器当TP找不到请求的控制器的时候，会去找EmptyController，和空操作一样，页可以定制错误界面和URL优化 注：CONTROLLER_NAME代表的是当前请求的控制器名称","categories":[],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"TP框架学习笔记(路由)","slug":"TP框架学习笔记(路由)","date":"2018-07-24T14:41:57.890Z","updated":"2018-07-26T15:00:38.157Z","comments":true,"path":"2018/07/24/TP框架学习笔记(路由)/","link":"","permalink":"http://yoursite.com/2018/07/24/TP框架学习笔记(路由)/","excerpt":"","text":"路由URL的三种模式 动态URL eg: www.example.com/index.php?id=1 这种在URL中使用”?,=,&amp;”等传递参数的URL被称为动态路由 静态URL eg: www.example.com/index.html 这种常以”.html,.htm,.xml”结尾的网站与后台没有交互，不需要编译即可运行 伪静态URL eg: www.example.com/post/1 这种URL看起来像是静态页面，但是其实不是静态页面，只是运用了URL Rewrite技术来优化搜索引擎 TP的路由 普通模式：http://www.example.com/index.php?m=home&amp;c=index&amp;a=index pathinfo模式：http://www.example.com/index.php/home/index/index rewrite模式：http://www.example.com/home/index/index 兼容模式：http://www.example.com/index.php?s=home/index/index TP通过URL_ROUTER_ON来开启自定义路由规则，并且通过URL_ROUTE_RULES来定义路由的规则 路由定义的一般规则：&quot;路由表达式&quot; =&gt; &quot;路由地址和参数&quot; 路由表达式：以何种规则匹配浏览器中的地址，如果匹配成功，系统在处理请求的同时把传入参数传给制定动作 路由表达式支持：规则路由，正则路由，静态路由 规则路由eg: &#39;posts/:yead/:month/:day&#39; =&gt; &#39;Index/index&#39; 通过:来进行参数匹配，如果匹配成功，则将该为孩子的参数传给制定的动作 正则路由eg: &#39;/^posts\\/(\\d{4})\\/(\\d{2})\\/(\\d{2})$/&#39; =&gt; &#39;Index/index?year=:1&amp;month=:2&amp;day=1&#39; 通过正则匹配来匹配URL 静态路由注意：静态路由通过URL_MAP_RULES定义 eg: &#39;site/welcome&#39; =&gt; &#39;Index/index?from=seo","categories":[],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]}]}